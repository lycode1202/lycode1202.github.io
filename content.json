{"meta":{"title":"寜笙的博客","subtitle":"Coding","description":"代码尽头谁为峰，一见秃头道成空。","author":"寜笙","url":"https://lycode1202.github.io"},"pages":[{"title":"404","date":"2020-10-03T10:19:22.000Z","updated":"2022-03-06T03:41:24.190Z","comments":true,"path":"404.html","permalink":"https://lycode1202.github.io/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2022-03-09T14:33:22.784Z","updated":"2022-03-09T14:33:22.784Z","comments":true,"path":"api/index.html","permalink":"https://lycode1202.github.io/api/index.html","excerpt":"","text":"API接口合集影视音频接口 网易云音乐 知乎专栏 豆瓣一刻 考拉FM 蜻蜓FM Musixmatch 猫眼电影 平台接口 阿里云市场 API-免费API数据接口平台-京东万象 小白开放平台 进制数据 iDataAPI apishop 注册可以免费使用（不是永久免费，赠送次数超过需要缴费） 聚合数据 注册部分可以免费使用，有的需要收费 百度AI开放平台 涵盖图像处理、自然语言、语音技术、知识图谱、数据智能、AR、视频技术和深度学习八大方面 人脸识别Face++ 注：申请试用的API Key可以免费试用他上面的接口 淘宝开放平台 微博开放平台 马化腾的微信开放平台（对应的还有腾讯开放平台） 融云IM 地图接口 高德地图 百度地图 腾讯地图 搜狗地图 天气接口 丫丫天气 心知天气 和风天气 快递接口 快递100 快递网 AI接口 百度AI市场 智能机器人 笔记接口 OneNote 有道云笔记 印象笔记","raw":null,"content":null},{"title":"friends","date":"2022-03-05T07:17:29.000Z","updated":"2022-03-05T07:17:49.786Z","comments":true,"path":"friends/index.html","permalink":"https://lycode1202.github.io/friends/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"download","date":"2022-03-07T09:32:47.000Z","updated":"2022-03-07T09:32:47.356Z","comments":true,"path":"download/index.html","permalink":"https://lycode1202.github.io/download/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"about","date":"2022-03-05T03:52:03.000Z","updated":"2022-03-07T10:11:57.115Z","comments":true,"path":"about/index.html","permalink":"https://lycode1202.github.io/about/index.html","excerpt":"","text":"个人简介（以后再写）我是一个帅哥，哈哈哈，过于自恋了！！","raw":null,"content":null},{"title":"categories","date":"2022-03-05T03:39:25.000Z","updated":"2022-03-05T03:50:49.945Z","comments":true,"path":"categories/index.html","permalink":"https://lycode1202.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2022-03-05T03:51:07.000Z","updated":"2022-03-05T03:51:27.158Z","comments":true,"path":"tags/index.html","permalink":"https://lycode1202.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"","slug":"线性回归","date":"2023-05-31T07:28:54.018Z","updated":"2023-06-04T07:32:20.940Z","comments":true,"path":"2023/05/31/xian-xing-hui-gui/","link":"","permalink":"https://lycode1202.github.io/2023/05/31/xian-xing-hui-gui/","excerpt":"","text":"基本概念 什么是回归预测？什么是分类预测？ 模型 输入变量 预测结果 应用 回归预测 实值离散 一个连续值域上的任意值 预测值的分布情况 分类预测 实值离散 两个或多个分类值 将输入变量分类到不同类别 思考一个问题：分类问题是否可以转变为回归问题？ 回答：当然可以！ 例子：检测癌症患者患病概率，检查值可能是40%、50%、60%等连续值，但是如果我们给定一个划分标准，如高于50%的检查值认定为患病，那么我们就把一个回归问题转化成了分类问题。 什么是线性？ 可加性，又称叠加性 f(x+y)=f(x)+f(y) 齐次性，又称均匀性 f(ax)=af(x)，其中a为与x无关的常数 f(x,y)=f(ax+by)=af(x)+bf(y) 什么是线性回归（LinearRegression）？ 顾名思义：用一条线来进行回归预测。 例子：已知房屋面积和房屋价格的对应关系，100平60w；120平70w；130平75w。根据对应的散列点在二维空间描绘出来得到下图： 线性回归在这种背景下的工作就是寻找一条直线，尽可能的拟合这些离散点。 什么是拟合？ 专业的来说：针对数据(x1,y1)、(x2,y2)，…，(xn,yn)，确定一个函数f(x)使得尽可能的准确表达这些变量间的关系。 拟合不一定是百分百的，如上图的这些离散点，根据两点确定一条直线的原则，你无法找到一条能够完全穿过这些点的直线，因此不同人可能会找到不同的直线，如下图： 这么多条线，我们的应该选取哪一条作为最终的f(x)呢？针对这个问题，我们引入了一个评判指标——损失函数 什么是损失函数（loss function）？ 首先我们明确一个概念： 图上这条直线上的点称为预测点，图上这些离散的点称为真实点。既然是预测就会存在误差，这里我们把真实值和预测值之间的差值称为——残差 残差公式：$$e = y - \\hat y$$ 对于单个具体点我们可以用残差来衡量评估标准，但对于图中所有的点，我们要进行整体评估，因此数学上一般将所有点的残差的平方加和等到一个总和 残差平方和公式（SSE）：$$Q = \\sum_{i=1}^{n}(y_i-\\hat y_i)^2=\\sum_{i=1}^{n}(y_i-(\\hat \\beta_0+\\hat \\beta_1x_i))^2$$我们可以通过这个SSE公式来评估我们的直线的误差，不断动态调整我们的直线，尽可能逼近最小误差 这个时候又会有另外一个疑问，误差评判标准是唯一不变的吗？ 针对这个问题，马克思曾说过：要具体问题具体分析。因此损失函数的选择不是唯一的，但是有些函数常常会被我们用到，举例如下： 均方误差MSE $$\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat y_i)^2$$ 均方根误差RMSE $$\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat y_i)^2}$$ 平均绝对误差MAE $$\\frac{1}{n}\\sum_{i=1}^{n}|y_i-\\hat y_i|$$ 根均方百分比误差RMSPE $$\\frac{1}{n}\\sqrt{\\sum_{i=1}^{n}(\\frac{y_i-\\hat y_i}{y_i})^2}$$ 由于篇幅有限加上初期接触，这里不再过多拓展，更多详情在损失函数拓展篇 这个时候就会有人说，是不是我选择了一个好的损失函数，并且使其损失值最小化。我的模型就可以在工业应用中有着优秀表现呢？ 答案可能是不一定的，还是那句话具体问题要具体分析，因此我们引入了另外一个评估角度——评价指标 什么是评价指标（evaluation metric）？ 既然要去评价一个东西，那必须多维度全方面的去评估，因此机器学习中给出了一些常用的评价指标。 这里我们以“二分类”问题为例，所谓二分类就是把一个东西分成两类，看各自分类的正确率和错误率。 Confusion Matrix（混淆矩阵） 真实情况 预测结果 正例 反例 正例(P) TP（真正例） FN（假反例） 反例(N) FP（假正例） TN（真反例） ​ Accuracy（准确率） 真实情况和预测结果一致的样本占总样本的比例$$Accuracy =\\frac{TP+TN}{P+N}$$ Precision（精准率）(又称查准率) 被分为正例中真实情况为正例的比例$$Precision =\\frac{TP}{TP+FP}$$ Recall（召回率）（又称查全率） 真实情况中正例被正确分类的比例$$Recall =\\frac{TP}{TP+FN}$$ F1 Score（F1分数） F1值是评估二元分类模型性能中精准性和召回率综合效果的指标$$F_1 =\\frac{2·Precision·Recall}{Precision+Recall}=\\frac{2TP}{2TP+TP+FN}$$ AUC（ROC曲线下面积） AUC的值可以表示为预测模型对于随机选择一个正样本和一个负样本能够给出正确的分类预测的概率大小。因此AUC的值越大，说明模型的分类效果越优秀 ROC曲线以真阳性率为纵坐标，以假阳性率为横坐标绘制的性能评价曲线。 其中真阳性率为$$\\frac{TP}{P}$$假阳性率为$$\\frac{FP}{N}$$ ROC曲线越靠近左上角，说明其对应模型越可靠。ROC曲线下面的面积（Area Under Curve, AUC）越大，模型越可靠。 R-squared（R平方） R方，决定系数，又称拟合优度，通常用来描述数据对模型拟合程度的好坏，表示自变量X对因变量Y的解释程度。R方的取值在[0,1]之间，越接近1，说明回归拟合效果越好。比如R方=0.5，那么说明自变量可以解释因变量50%的变化原因。 $$R^2 = 1-\\frac{\\sum_{i=1}^{n}(y_i-\\hat y_i)^2}{\\sum_{i=1}^{n}(y_i-\\bar y_i)^2} = 1-\\frac{SSE}{SST}=\\frac{SSR}{SST}$$ 具体内容针对前面的铺垫内容，我们来开始对线性模型的具体学习，一般我们在实际应用中待检测的物体都有多种属性，根据多个属性值x来确定最终的结果值y。用数学描述如下：$$属性值x =\\left(\\begin{matrix} x_{1} \\ x_{2} \\ \\vdots \\ x_{d} \\\\end{matrix}\\right) 对应属性值的权重值w=\\left(\\begin{matrix} w_{1} \\ w_{2} \\ \\vdots \\ w_{d} \\\\end{matrix}\\right)$$ 线性回归模型：$$f(x)=w_1x_1+w_2x_2+…+w_dx_d+b$$向量形式：$$f(x)=w^Tx+b$$ 将问题抽象成数学公式后，就转化成了对w、b值进行求解的数学问题，那如何求解出w和b呢？ 上一节讲到的损失函数就是重要的解题依据，我们采用均方误差最小化的形式来使f(x)无限逼近真实值，从而确定w和b 首先对于单个属性值的预测结果$$f(x_i)=wx_i+b 使得 f(x_i)\\backsim y_i$$ 使得均方误差最小化：（因为1/m是固定值，不影响最后结果可以省去）$$(w^*,b^*)=argmin\\sum_{i=1}^{m}(f(x_i)-y_i)^2=argmin\\sum_{i=1}^{m}(y_i-wx_i-b)^2=argminE_{(w,b)}$$ 应用：最小二乘法：找到一条直线，使得所有样本到直线上的欧式距离之和最小 分别对w、b求导可得 $$\\frac{\\partial E_{(w,b)} }{\\partial w}=2(w\\sum_{i=1}^{m}x_i^2-\\sum_{i=1}^{m}(y_i-b)x_i)$$ $$\\frac{\\partial E_{(w,b)}}{\\partial b}=2(mb-\\sum_{i=1}^{m}(y_i-wx_i))$$ 令导数值为0得到w、b表达式 多元线性回归上述我们对单个属性对应的单个w和b进行计算，但是在实际应用中，样本数据中可能会有多个属性，他们共同影响着最终的预测值f(x)，因此我们要把一维的情况拓展到多维，得到更一般的表达式：$$f(x_i)=w^Tx_i+b,使得f(x_i)\\backsim y_i$$ 将w和 吸收入向量中：$$\\hat{w}=\\left(\\begin{matrix} w_{1} \\ w_{2} \\ \\vdots \\ w_{d} \\ b \\\\end{matrix}\\right) = \\left(\\begin{matrix} w \\ b \\\\end{matrix}\\right)$$ $$X = \\left[\\begin{matrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1 \\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\ x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{md} &amp; 1 \\\\end{matrix}\\right] = \\left[\\begin{matrix} x_1^T &amp; 1 \\ x_2^T &amp; 1 \\ \\vdots &amp; \\vdots \\ x_m^T &amp; 1 \\\\end{matrix}\\right] = \\left[\\begin{matrix} X_1\\ X_2\\ \\vdots \\ X_m\\\\end{matrix}\\right]$$ 所有样本点对应的真实值：$$y = \\left(\\begin{matrix} y_{1} \\ y_{2} \\ \\vdots \\ y_{m} \\\\end{matrix}\\right)$$对于单个样本的预测值可以如下式子表示：$$f(x_1) = x_1^T · w + b = X_1·\\hat{w}$$所有样本的预测值可以如下式子表示：$$f(x) = X\\hat{w}$$因此多元情况下的差值函数也类似于单元，可以利用向量进行运算。$$差值² = (y_i-f(x_i))^2 = (y-X\\hat{w})^2=(y-X\\hat{w})^T(y-X\\hat{w})$$利用最小二乘法来找到合适的w、b值$$(w^*,b^*)=\\hat{w}^*=argmin(y-X\\hat{w})^T(y-X\\hat{w})$$ $$\\frac{\\partial E_{\\hat{w}}}{\\partial \\hat{w}} = 2X^T(X\\hat{w}-y)$$ $$\\hat{w}^* = (X^TX)^{-1}X^Ty$$ $$f(\\hat{x}_i) = X\\hat{w} = \\hat{x}_i(X^TX)^{-1}X^Ty$$ 阅读到这里我们要去思考一个问题，就是对于X^TX这个矩阵，它是否一定可逆呢？ 答案是不一定的，因此可能在实际求解中，w有多个值，均可以使差值最小化。 拓展知识：$$\\frac{\\partial (x^T A x)}{\\partial x}=Ax+A^Tx，其中A是常数矩阵$$ $$\\frac{\\partial(x^T \\alpha)}{\\partial x}=\\frac{\\partial(\\alpha^Tx)}{\\partial x}=\\alpha，其中a为常数向量$$ 广义线性模型针对之前学习的线性回归模型思考几个问题： x与y之间的变化不是线性的，存在非线性关系还可以像之前那样定义吗？ 预测数据和真实之间的差值不是常数，且随x变化，如何来界定呢？ 线性回归假设在因变量正态分布的前提上，导致因变量必须是连续的，若是离散值如何处理呢？ 因此在原来线性回归的基础上又衍生出了种类繁多的线性类模型。 在线性回归基础上，在等号的左边或右边加上了一个函数，从而能够让模型更好的捕捉一般规律，此时该模型就被称为广义线性模型，该函数就被称为联系函数。广义线性模型的提出初衷上还是为了解决非线性相关的预测问题。 $$y = g^{-1}(w^Tx+b) 其中g(·)是联系函数$$ 实战解析（讲的很好） 逻辑回归模型（对数几率回归）事先申明，虽然它叫逻辑“回归”，但是它的主要任务是进行二分类。 几率（odd）与对数几率 几率不是概率，而是一个事件发生与不发生的概率的比值。假设某件事发生的概率为p，则该件事不发生的概率为1-p，则该事件的几率：$$odd(p)=\\frac{p}{1-p}$$在几率的基础上取e为底的对数，怎么这件事的对数几率（logit）：$$logit(p)=ln\\frac{p}{1-p}$$对数几率模型 如果我们将对数几率看成是一个函数，并将其作为联系函数，则该广义线性模型为：$$g(y)=ln\\frac{y}{1-y}=\\hat w^T·\\hat x$$可以将其反解出来： 我们将其抽象成数学公式的话，其实可以表示为：$$f(z) =\\frac{1}{1+e^{-z}}$$那我们将这个图像绘制出来看看它的特性： 读到这里大家可能会产生疑问： 为什么非得探讨对数的情况？指数、绝对值情况不可以吗？ 为什么最后是sigmoid函数，不可以是其他的函数吗？ 拓展了解广义线性回归 数学基础：伯努利分布、极大似然估计、高斯(正态)分布、梯度下降 引入了sigmoid函数，我们可以做什么？ 我们假设有一个分类任务，我们要求出正例和反例各自的概率，不妨假设预测函数就是sigmoid函数，具体示例如下：$$h_{\\theta}(x)=g({\\theta}^Tx)=\\frac{1}{1+e^{ {-\\theta}^Tx} } ，其中\\theta = (w;b)$$ $$正例：P(y=1|x;\\theta)=h_{\\theta}(x) 反例：P(y=0|x;\\theta)=1-h_{\\theta}(x)整合：P(y|x;\\theta)=(h_{\\theta}(x))^y(1-h_{\\theta}(x))^{1-y} ，其中二分类任务y只取0,1$$ 似然函数：$$L(\\theta)=\\prod_{i=1}^mP(y_i|x_i;\\theta) =\\prod_{i=1}^m(h_{\\theta}(x_i))^{y_i}(1-h_{\\theta}(x_i))^{1-y_i}$$ 概率的连乘会使最后数据过小无法有效计算，想办法消去连乘，便引进了对数似然函数：$$l(\\theta)=logL(\\theta)=\\sum_{i=1}^{m}(y_ilogh_\\theta(x_i)+(1-y_i)log(1-h_\\theta(x_i)))$$此时要求对数似然函数的最大值：但是求最大是一个梯度上升的问题，我们平常所熟悉的是梯度下降的问题，那就要进行问题的转化。$$J(\\theta)=- \\frac{1}{m}l(\\theta)$$利用梯度下降方法求出迭代方向（即导数值） $$x_i^j 表示第i个样本的第j个特征$$参数更新：$$\\theta_j :=\\theta_j-\\alpha\\frac{1}{m}\\sum_{i=1}^{m}(h_\\theta(x_i)-y_i)x_i^j$$这个式子中的α表示更新的步长（学习率），后面表示方向。方向乘以步长表示我要更新的内容 拓展：多分类的softmax 类别不平衡问题什么时候需要去处理类别不平衡的问题： 当一个样本中的“小类”比样本中的“大类”更为重要时才需要对类别不平衡进行处理。 推荐讲解：周志华老师西瓜书 本文为机器学习入门篇，暂时不对复杂问题进行探讨。对于中间提到的公式最好是手动推导！","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"科研基础知识","date":"2023-05-21T02:00:34.385Z","updated":"2023-05-21T07:07:59.504Z","comments":true,"path":"2023/05/21/ke-yan-ji-chu-zhi-shi/","link":"","permalink":"https://lycode1202.github.io/2023/05/21/ke-yan-ji-chu-zhi-shi/","excerpt":"","text":"分区 SCI《科学引文索引》期刊分为四部分： 科学引文索引（Science Citation Index Expanded） 社会科学引文索引（Social Sciences Citation Index） 艺术与人文文献索引（Arts and Humanities Citation Index） 新兴科学引文索引（Emerging Sources Citation Index） EI《工程索引》 范围高于SCI CPCI/ISTP会议（科技会议录索引） jcr Q1（前25%） Q2（26%-50%） Q3（51%-75%） Q4（76%-100%） 中科院 1区（前5%） 2区（6%-20%） 3区（21%-50%） 4区（51%-100%） 类别 自然科学 社会科学 艺术与人文科学 网站 https://www.webofscience.com/wos/alldb/basic-search 科普知识 影响因子 $$if = \\frac{期刊发表论文被引用的次数}{总共发表论文的总数}$$ 期刊查询中文期刊 知网（https://navi.cnki.net/knavi/#） 外文期刊 letpub（https://www.letpub.com.cn/index.php?page=journalapp） 小木虫 计算机期刊 中国计算机协会（CCF）（https://www.ccf.org.cn/Academic_Evaluation/By_category/） A类 B、C类 Computer Science Conference Rankings (CORE) （顶会） 计算机学报 软件学报 计算机研究与发展 刊号 CN：国内刊号 ISSN：国外刊号 较为容易申请 核心 北大核心（北大中文核心) 作为普及最广的北大核心； 南大核心（中文社会科学引文索引(CSSCI)来源期刊） 作为最权威的南大核心； 科技核心（中国科技论文统计源期刊(CSTPCD)) 又名“统计源核心”，全称“科技统计源核心期刊”。目录每年更新一次，分为社会科学卷和自然科学卷。可从中信所官网下载目录，知网上并不会标注。 作为医药机构的科核 CSCD（中国科学引文数据库) 作为理科的CSCD","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"md数学公式","date":"2023-05-14T10:40:01.574Z","updated":"2023-05-14T11:15:06.083Z","comments":true,"path":"2023/05/14/md-shu-xue-gong-shi/","link":"","permalink":"https://lycode1202.github.io/2023/05/14/md-shu-xue-gong-shi/","excerpt":"","text":"插入格式 $$ 数学公式 $$$$y = ax + b$$ 代码 描述 $x^{2}$ 上标 $x_{i}$ 下标 $\\langle$ ⟨ $\\rangle$ ⟩ ${$ { $}$ } $\\frac{x}{y} $ 分数 $\\sqrt{2}$ 根号 $\\sqrt[n]{5}$ n次根号 $\\vec{x}$ 向量 x $\\overleftarrow{x}$ x 上方左箭头 $\\overrightarrow{x}$ x 上方右箭头 $\\leftarrow$ 左箭头 $\\rightarrow$ 右箭头 $\\uparrow$ 向上的箭头 $\\downarrow$ 向下的箭头 $\\Leftarrow$ 双向左箭头(其余同例) $a \\otimes b$ a⊗b 外积 $\\langle a , b \\rangle$ ⟨a,b⟩ 内积 $a \\cdot b$ a⋅b 点乘 $a \\times b$ a×b 叉乘 $\\sin$ sin $\\angle A$ ∠A $\\cong$ ≅ $\\backsim$ ∽ $\\log$ log $\\emptyset$ ∅ $\\in$ ∈ $\\notin$ 不属于 $\\subset$ 真包含于 $$\\int_{0}^{1}{x^{3}}dx$$ $$ \\lim_{x \\to \\infty} \\frac{1}{n(n+1)}$$ $$\\sum_{i=0}^{n} x_i$$ $$\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} \\Bbb{R}$$ $$f(x)= \\begin{cases} 0,&amp; \\text{if x is even} \\ 1, &amp; \\text{if x is odd} \\end{cases}$$ $$\\begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{matrix}$$ $$ \\left{ \\begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right} \\tag{2}$$ $$\\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right]$$ $$\\left[\\begin{matrix} 1 &amp; 2 &amp; \\cdots &amp; 4 \\ 7 &amp; 6 &amp; \\cdots &amp; 5 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 8 &amp; 9 &amp; \\cdots &amp; 0 \\\\end{matrix}\\right]$$","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"机器学习","date":"2023-05-14T06:10:34.804Z","updated":"2023-06-02T14:17:59.709Z","comments":true,"path":"2023/05/14/ji-qi-xue-xi/","link":"","permalink":"https://lycode1202.github.io/2023/05/14/ji-qi-xue-xi/","excerpt":"","text":"线性模型 线性模型试图学得一个通过属性的线性组合来进行预测的函数$$f(x)=w_1x_1+w_2x_2+…+w_dx_d+b$$向量形式：$$f(x)=w^Tx+b$$ 单线性回归$$f(x_i)=wx_i+b 使得 f(x_i)\\backsim y_i$$ 离散属性的处理：若有“序”（order），则连续化；否则，转化为k维向量 均方误差最小化：$$(w^*,b^*)=argmin\\sum_{i=1}^{m}(f(x_i)-y_i)^2=argmin\\sum_{i=1}^{m}(y_i-wx_i-b)^2$$ 应用：最小二乘法：找到一条直线，使得所有样本到直线上的欧式距离之和最小 分别对w、b求导可得$$\\frac{\\partial E(w,b)}{\\partial w}=2(w\\sum_{i=1}^{m}x_i^2-\\sum_{i=1}^{m}(y_i-b)x_i)$$ $$\\frac{\\partial E(w,b)}{\\partial b}=2(mb-\\sum_{i=1}^{m}(y_i-w_ix_i))$$ 令导数值为0得到w、b表达式 多元线性回归$$f(x_i)=w^Tx_i+b,使得f(x_i)\\backsim y_i$$ 将w和b吸收入向量中：$$\\hat{w}=(w;b)$$ $$X = \\left[\\begin{matrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1 \\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\ x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{md} &amp; 1 \\\\end{matrix}\\right] = \\left[\\begin{matrix} x_1^T &amp; 1 \\ x_2^T &amp; 1 \\ \\vdots &amp; \\vdots \\ x_m^T &amp; 1 \\\\end{matrix}\\right]$$ $$(w^*,b^*)=\\hat{w}^*=argmin(y-X\\hat{w})^T(y-X\\hat{w})$$ $$\\frac{\\partial E_{\\hat{w}}}{\\partial \\hat{w}} = 2X^T(X\\hat{w}-y)$$ $$\\hat{w}^* = (X^TX)^{-1}X^Ty$$ $$f(\\hat{x}_i) = X\\hat{w} = \\hat{x}_i(X^TX)^{-1}X^Ty$$ 广义线性模型$$y = g^{-1}(w^Tx+b) 其中g(·)是联系函数$$ 对数几率回归二分类问题 TP 将正类预测为正类 FN 将正类预测为负类 FP 将负类预测为正类 TN 将负类预测为负类 精确率 $$P = \\frac{TP}{TP+FP}$$ 召回率 $$R = \\frac{TP}{TP+FN}$$ 调和均值 $$\\frac{2}{F_1}=\\frac{1}{P}+\\frac{1}{R}$$ 输出标记 y∈{0,1} 预测值 z $$y =\\frac{1}{1+e^{-z}}=\\frac{1}{1+e^{-(w^Tx+b)}}$$ $$ln\\frac{y}{1-y} = w^Tx+b ,其中\\frac{y}{1-y}称为几率(odds)$$ 类别不平衡问题 正类和负类个数并不相同，差距较大 $$原先 \\frac{y}{1-y}&gt;1,则预测为正例。判断条件改进为\\frac{y}{1-y}&gt;\\frac{m^+}{m^-}$$ 决策树信息增益“信息熵”是度量样本集合纯度的指标，针对数据集D的信息熵为：$$Ent(D) = -\\sum_{k=1}^{|y|}p_klog_2p_k$$Ent(D)越小，D纯度越高 针对属性a对样本集D进行划分所获得的“信息增益”$$Gain(D,a)=Ent(D)-\\sum_{v=1}^{V} \\frac{|D^v|}{|D|}Ent(D^v)$$信息增益大的用来划分属性，但是有些属性划分不具有泛化能力（如：序号） 增益率$$Gain-ration(D,a)=\\frac{Gain(D,a)}{IV(a)}$$ $$IV(a) = -\\sum_{v=1}^{V}\\frac{|D^v|}{|D|}log_2\\frac{|D^v|}{|D|}$$ 先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的 基尼指数数据集D的纯度用来度量：$$Gini(D)=\\sum_{k=1}^{|y|}\\sum_{k’≠k}p_kp_{k’}=1-\\sum_{k=1}^{|y|}p_k^2$$ 剪枝处理(pruning)解决“过拟合”现象 预剪枝 提前不让树枝长出来 最大深度限制：设定决策树的最大深度，当达到设定的最大深度时停止分支。 叶子节点样本数限制：设置一个阈值，当某个节点上的样本数量小于该阈值时，停止分支，将该节点作为叶子节点。 不纯度减小阈值：计算每个节点的不纯度（如基尼指数、熵），设定一个阈值，当分支后不纯度的减小量低于该阈值时，停止分支。 类别纯度阈值：判断节点上的样本是否属于同一类别，当节点的类别纯度达到设定阈值时，停止分支。 特征重要性评估：在决策树构建过程中，实时评估每个特征的重要性，当某个特征的重要性低于一定阈值时，停止分支。 后剪枝 构建完整的决策树：使用训练数据构建完整的决策树，直到每个叶子节点都包含纯净的类别或达到预定的停止条件。 评估子树的准确性：对于每个非叶子节点，考虑其子树的整体准确性，可以使用交叉验证、验证集或其他评估方法来评估子树的性能。 执行剪枝操作：从决策树的底部开始逐步剪枝，将子树替换为叶子节点，并将叶子节点的类别设置为该子树中最常见的类别。然后，通过比较剪枝前后的整体准确性来确定是否剪枝。 重复剪枝操作：循环执行步骤3，逐步剪枝决策树的其他子树，直到不能再获得更好的性能为止。 连续与缺失值神经网络感知机 二分类的线性模型 梯度下降 一个超平面S能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧 损失函数 输入空间R中任一点x到超平面S的距离 $$d = \\frac{1}{||w||}|w·x_0+b|$$ $$范式||w|| = \\sqrt{w_1^2+w_2^2+…+w_n^2}$$ 误分类 $$-y_i(w·x_i+b)&gt; 0$$ 感知机学习损失函数 $$L(w,b)=-\\sum_{x_i∈M}y_i(w·x_i+b)$$ 感知机学习的策略是在假设空间中选取损失函数式最小的模型参数w，b 迭代求最好的w、b值 η（0 &lt; η ≤ 1）是学习步长，又称学习率 $$\\frac{\\partial L}{\\partial w}=-\\sum_{i=1;x∈M}^{n}y_ix_i$$ $$\\frac{\\partial L}{\\partial b}=-\\sum_{i=1;x∈M}^{n}y_i$$ $$w = w + \\eta \\frac{\\partial L}{\\partial w}$$ $$b = b + \\eta \\frac{\\partial L}{\\partial b}$$ 感知机算法过程 选取初值w、b 在训练集中选取数据（x，y） 如果y(wx+b) ≤ 0, 改变w、b的值 重复至第二步，直至训练集中没有误分类点 证明上述结论：$$\\hat{w}k·\\hat{w}{opt} ≥ k \\eta \\gamma$$ $$||w_k||^2 ≤ k \\eta^2 \\gamma^2$$ 对偶形式 $$w = \\sum_{i=1}^{N} \\alpha_iy_ix_i$$ $$b = \\sum_{i=1}^{N}\\alpha_iy_i$$ 这里的α就是误分类点出现的次数 Gram矩阵 $$G = [x_i,x_j]_{N×N}$$ K近邻 给定一个数据集，对于新输入的实例，在训练数据集中找到与该实例最接近的k个实例，这k个实例的多数属于哪个类，就把它划分到哪个类 三个参数 距离度量 欧式距离 由于不同的距离度量所确定的最近邻点是不同的 k值的选择 太小过拟合 太大无异议 分类决策规则 多数表决规则 = 经验风险最小化 kd树 kd树的查找 kd树构建完毕后，利用kd树进行k近邻搜索。在kd树上进行近邻搜索时，很多时候可以不进入某个父节点的另一个子节点（省去了另一个子节点数据点的查找）。kd树查找的具体算法如下：算法输入：构造完毕的kd树，需要分类的目标点x算法输出：目标点x的k近邻点算法过程： （1）通过深度优先方法，在kd树中搜索到目标点的所在的叶节点。（注：该搜索并不能直接找到最近邻点）搜索方法如下，在搜索每一层的过程中，根据该层的分割特征的序数，来对目标点的该序数的特征进行分类（决定是进入左子节点还是右子节点）。（2）以该叶节点作为当前的NN（最近邻）点，计算该叶节点与目标点的距离，并设为当前的最小距离。（3）计算该叶节点父节点与目标点的距离，若小于当前的最小距离，则更新当前的最小距离以及当前的NN点（被覆盖的点先记录下来）（4） 判断是否要进入父节点的另一个子节点： 判断方法为：计算父节点在其分割特征上的值距离目标点在该特征上的值的距离，若该距离小于当前的最小距离，则进入另一个子节点，否则不进入。既：检查另一子节点对应的区域是否与以目标点为球心，以目标点与当前的NN点的距离为半径的球体相交。若相交则进入，反正不进入。 a）若不进入另一个子节点，则以此父节点视为叶节点，重复步骤3。 b）若进入另一个子节点，则对右边节点以下的子树执行步骤1，找到新的叶节点。判断是否要更新NN点与当前最小距离。随后以该叶节点开始，重复步骤3。 以此类推，搜索过程中将不断向跟节点回退。在向根节点回退的过程中，不必再次进入从中退出的子节点，保证过程不会进入死循环。 5 当回退到根节点时（且以根节点与目标点的距离来更新最小距离与NN点后），最后的NN点即为x的最近邻点。且记录下来的所有NN点，对应的距离，最小的K个即为K近邻点。如果实例点是随机分布的，则kd树搜索的平均及计算复杂度是O（logN） 贝叶斯分类器什么是贝叶斯？？ 什么是正态分布？？ 对给定的输入x，通过学习到的模型计算后验概率分布P，将后验概率最大的类作为x的类输出。——生成学习的方法$$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\sum_{k}P(X=x|Y=c_k)P(Y=c_k)}$$朴素贝叶斯分类器$$y = f(x)= argmax\\frac{P(Y=c_k)\\quad\\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\\sum_{k}P(X=x|Y=c_k)\\quad\\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}$$ 因为分母对所以C_k都是相同的，所以：$$y = P(Y=c_k)\\quad\\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$根据算数得出期望风险最小化准则就得到了后验概率最大化准则：$$f(x) = argmaxP(C_k|X=x)$$ 逻辑斯蒂回归与最大熵模型逻辑斯蒂回归逻辑斯蒂分布中的分布函数和密度函数：$$F(x) = P(X≤x)=\\frac{1}{1+e^{-(x-u)/r}}$$ $$f(x)=F^{‘}(x)=\\frac{e^{-(x-u)/r}}{r(1+e^{-(x-u)/r})^2}$$ F(x)关于点（u，½）中心对称$$F(-x+u)-1/2=-F(x-u)+1/2$$ 最大熵模型在已有条件约束下，在模型集合中选择熵最大的模型（即最优化的模型） 熵：$$H(P) = -\\sum_{x}P(x)logP(x)$$ $$0 ≤ H(P) ≤log|X| (|X|是X的取值个数)$$ 最大熵模型：$$H(P) = - um$$ 集成学习聚类降维与度量学习特征选择与系数学习计算学习理论半监督学习概率图模型规则学习强化学习","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"conda命令","date":"2023-04-15T03:29:00.798Z","updated":"2023-04-17T15:10:45.292Z","comments":true,"path":"2023/04/15/conda-ming-ling/","link":"","permalink":"https://lycode1202.github.io/2023/04/15/conda-ming-ling/","excerpt":"","text":"conda命令conda下载包是通过一些chanel来访问下载的，原本内置的有一些chanel，另外一些包需要自己添加下载所需的chanel。 1.查看chanel： conda config --show 2.添加chanel： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 3.删除chanel： conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 4.conda搜索某个包及可安装的版本信息（以scikit-learn包为例）： conda list #查看目前以安装的包 conda env list #查看目前安装的虚拟环境 conda search scikit-learn #查看scikit-learn是否可安装 5.conda安装指定版本的包： conda install scikit-learn=0.23.1 6.conda卸载包： conda uninstall scikit-learn conda remove [package] 7.conda升级包： conda update scikit-learn 8.conda缓存清理（conda报错segment fault的时候就是需要清理缓存哦）： conda clean -p //删除没有用的包 conda clean -t //删除tar包 conda clean -y --all //删除所有的安装包及cache 9.conda创建环境，激活、使用、关闭： conda create -n myenv python=3.5 #创建python3.5名字叫myenv虚拟环境 conda activate myenv #开启myenv环境 conda deactivate #关闭环境 conda env list #显示所有的虚拟环境 conda remove --name myenv --all #删除创建的myenv环境 10.创建一个新环境 conda create -n your_env_name python=X.X conda create --name your_env_name python=X.X -n即--name，your_env_name是你自定义的环境名称。 例：conda create -n newenv python=3.7 11.激活某个环境 Windows系统： conda activate your_env_name Linux系统： source activate your_env_name 12.退出当前虚拟环境 source deactivate # Linux环境 conda deactivate # Windows环境 13.删除某个虚拟环境： conda remove -n your_env_name --all 14.分享/备份环境一个分享环境的快速方法就是给他一个你的环境的.yml文件。 首先激活到要分享的环境，在当前工作目录下生成一个environment.yml文件。 conda env export &gt; environment.yml 对方拿到environment.yml文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境。 conda env create -f environment.yml 15.镜像源 查看镜像源： conda config --show channels 删除镜像源： conda config --remove channels xxx 添加镜像源（如清华源）： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/ conda config --add channels http://mirrors.aliyun.com/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"cv实战","date":"2023-04-10T06:05:08.593Z","updated":"2023-04-24T06:17:35.521Z","comments":true,"path":"2023/04/10/cv-shi-zhan/","link":"","permalink":"https://lycode1202.github.io/2023/04/10/cv-shi-zhan/","excerpt":"","text":"数据分析部署环境(base) $ conda config --add channels conda-forge (base) $ conda config --set channel_priority strict (base) $ conda create -y -n pydata-book python=3.10 (base) $ conda activate pydata-book //进入pydata-book 安装依赖题外：尽量全部使用conda安装，不成功再用pip (pydata-book) $ conda install -y pandas jupyter matplotlib conda install lxml beautifulsoup4 html5lib openpyxl requests sqlalchemy seaborn scipy statsmodels patsy scikit-learn pyarrow pytables numba IPython(pydata-book) ipython In [1]: a = 5 In [2]: a Out[2]: 5 In [3]: import numpy as np In [4]: data = [np.random.standard_normal() for i in range(7)] In [5]: data Out[5]: [-0.20470765948471295, 0.47894333805754824, -0.5194387150567381, -0.55573030434749, 1.9657805725027142, 1.3934058329729904, 0.09290787674371767] Jupyter Notebook(pydata-book) Jupyter Notebook 重命名：单击页面顶部的笔记本标题并键入新标题，完成后按 Enter 数据结构 元组：元素不能随意更改 字符串转元祖 tup = tuple('string') 变量拆包： In [34]: values = 1, 2, 3, 4, 5 In [35]: a, b, *rest = values In [36]: a Out[36]: 1 In [37]: b Out[37]: 2 In [38]: rest Out[38]: [3, 4, 5] 列表 append insert pop sort 切片 字典 del pop update 集合 python基础 匿名 (Lambda) 函数 equiv_anon = lambda x: x * 2 In [201]: def apply_to_list(some_list, f): .....: return [f(x) for x in some_list] In [202]: ints = [4, 0, 1, 5, 6] In [203]: apply_to_list(ints, lambda x: x * 2) Out[203]: [8, 0, 2, 10, 12] 打开文件 In [233]: path = \"examples/segismundo.txt\" In [234]: f = open(path, encoding=\"utf-8\") In [237]: f.close() pytorch发展 Theano TensorFlow TensorFloweager Torch7 pytorch+THNN pytorch+Caffe2 Caffe Caffe2 Pytorch1.0","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"AI人工智能","date":"2023-04-08T13:10:43.993Z","updated":"2023-05-31T11:56:47.253Z","comments":true,"path":"2023/04/08/ai-ren-gong-zhi-neng/","link":"","permalink":"https://lycode1202.github.io/2023/04/08/ai-ren-gong-zhi-neng/","excerpt":"","text":"机器学习概念对于给定的任务T，在合理的性能度量方案P的前提下，程序可以自主学习任务T的经验E；随着提供合适、优质、大量的经验E，程序对于任务T的性能逐步提高 基本概念 dataset 数据集 instance 示例(没有结果的)/sample 样本(有结果的) attribute 属性/feature 特征 classification 分类 连续值 regression 回归 离散值 监督学习 分类 回归 无监督学习 聚类（类内差距最小化，类间差距最大化） 输入空间x → 输出空间y 映射f y=f(x) 泛化：训练模型适应新样本的能力 学习过程：在所以假设(hypothesis)组成的空间中进行搜索 归纳偏好：算法在学习过程中对某种类型假设的偏好 奥卡姆剃刀原理：若有多个假设与观察一致，则选最简单的那个 语义分割：图片中像素点分类从而进行物品的分类 VGG ResNet DensNet YOLO系列 RCNN系列 SSD DeepLab系列 U-Net SAM PAC 概率近似准确 $$P(|f(x)-y|≤\\epsilon)≥1-\\delta$$ NFL定理一个算法若在某些问题上比另一个算法好，必存在另一些问题一者比另一者好。 三大问题 评估方法 测试集应该与训练集“互斥” 留出法 分层采样 随机划分 测试集不能太大、太小 K-折交叉验证法 自助法 性能度量 比较检验 交叉验证t校验 k折交叉验证 McNemar检验（基于联列表，卡方检验） 分类前馈型神经网络反馈型神经网络自组织神经网络分支分支一：计算机视觉（CV）分支二：语音识别 鸡尾酒效应 同时多个声音出现，计算机无法准确识别各个说话主体，无法进行排异 分支三：文本挖掘/分类 关键字 分支四：机器翻译（MT）分支五：机器人Python-机器学习工具包package类型 Numpy FFT/Gauss/LSQ/SVD ndarray pandas DataFrame Series(Excel/csv/tsv) scipy Gamma Comb matplotlib scikit-learn ML tensorflow(Keras)/pyTorch/Theano(Keras)/Caffe/PandlePandle DL 安装包 pip IDE Anaconda PyCharm Numpy、matplotlib、pandas实操随机点阵图import numpy as np import matplotlib.pyplot as plt #随机点阵图 data = np.random.rand(1000, 2) print(data) x = data[:, 0] y = data[:, 1] plt.plot(x, y, 'go', markersize=1) plt.show() 效果： 随机柱状图import numpy as np import matplotlib.pyplot as plt #随机柱状图 p = np.random.rand(10000) np.set_printoptions(edgeitems=5000, suppress=True) plt.hist(p, bins=20, color='g', edgecolor='k') plt.show() 效果：（均匀分布） import numpy as np import matplotlib.pyplot as plt #迭代柱状图 N = 10000 times = 100 z = np.zeros(N) for i in range(times): z += np.random.rand(N) z /= times plt.hist(z, bins=20, color='m', edgecolor='k') 效果：（高斯分布） 随机生成数组 numpy -&gt; ndarray pandas -&gt; DataFrame import numpy as np import matplotlib.pyplot as plt import pandas as pd d = np.random.rand(3,4) print(d) print(type(d)) data = pd.DataFrame(data=d) print('='*50) print(data) print(type(data)) 随机折线图import numpy as np import matplotlib.pyplot as plt import pandas as pd x = np.linspace(0, 1, 100) print(x) y = x**x plt.plot(x, y, 'r-', lw=1) plt.show() 读写文本格式数据 前馈神经网络（BP算法）结构 输入层 隐层 输出层 损失函数$$\\sum_{Sample} \\sum_{i=1}^k (\\hat{y_k} - y_k)$$ 激活函数 Sigmoid函数 优点：输出范围有限(0,1) 缺点：梯度下降明显，两头平坦 -&gt; 梯度消失 $$\\psi(x)=\\frac{1}{1+e^{-x}}$$ tanh函数 优点：值域对称，完全可微分、反对称 缺点：梯度消失问题 $$tanh(x)=\\frac{e^x - e^{-x}}{e^x + e^{-x}}$$ ReLu函数 优点：线性，收敛速度快，无梯度饱和 $$R(z)=max(0,z)$$ 函数特性 非线性 可微性 单调性 f(x) ≈ x 输出值范围 计算简单 归一化 交叉熵二分类问题$$J(w)=\\frac{1}{N}\\sum_{n=1}^NH(p_n,q_n)=-\\frac{1}{N}\\sum_{n=1}^N[y_nlog\\hat{y_k} + (1-y_n)log(1-\\hat{y_k})]$$ 学习率（步长） 手动调整 固定学习率 动量法动态调整 随机梯度下降 Adam自动调整 过拟合防止方法： 参数范数惩罚 修改损失函数 -&gt; 惩罚函数 数据增强 提前终止 每过几个epoch来验证一次，查看是否过拟合了 Bagging等集成方法 Dropout 有概率的在训练中放弃一些神经元点 批正则化 归一化处理将一个数值组中最大最小值所在区间映射到[0,1]的区间上进行后续的数据处理","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"python爬虫","date":"2023-01-14T10:22:22.317Z","updated":"2023-02-20T07:05:42.878Z","comments":true,"path":"2023/01/14/python-pa-chong/","link":"","permalink":"https://lycode1202.github.io/2023/01/14/python-pa-chong/","excerpt":"","text":"python爬虫第一个爬虫from urllib.request import urlopen resp = urlopen(\"http://www.baidu.com\") # 打开 百度 print(resp.read().decode(\"utf-8\")) # 打印 抓取到的内容 with open(\"baidu.html\",mode=\"w\", encoding=\"utf-8\") as f: # 创建⽂件 f.write(resp.read().decode(\"utf-8\")) # 保存在⽂件中 web请求过程 ⻚⾯渲染数据的过程​ 1.服务器渲染 我们在请求到服务器的时候, 服务器直接把数据全部写⼊到html中, 我们浏览器就 能直接拿到带有数据的html内容. ⽐如, 由于数据是直接写在html中的, 所以我们能看到的数据都在⻚⾯ 源代码中能找的到的. 这种⽹⻚⼀般都相对⽐较容易就能抓取到⻚⾯内容 ​ 2.前端JS渲染 这种就稍显麻烦了. 这种机制⼀般是第⼀次请求服务器返回⼀堆 HTML框架结构. 然后再次请求到真正保存数据的服务器, 由这个服务器返回数据, 最后在浏览器上对数据进⾏加载 HTTP协议HTTP协议把⼀条消息分为三⼤块内容. ⽆论是请求还是响应都是三块内容 请求 请求⾏ -&gt; 请求⽅式(get/post) 请求url地址 协议 请求头 -&gt; 放⼀些服务器要使⽤的附加信息 请求体 -&gt; ⼀般放⼀些请求参数 响应 状态⾏ -&gt; 协议 状态码 响应头 -&gt; 放⼀些客户端要使⽤的⼀些附加信息 响应体 -&gt; 服务器返回的真正客户端要⽤的内容(HTML,json)等 请求头中最常⻅的⼀些重要内容(爬⾍需要): User-Agent : 请求载体的身份标识(⽤啥发送的请求) Referer: 防盗链(这次请求是从哪个⻚⾯来的? 反爬会⽤到) cookie: 本地字符串数据信息(⽤户登录信息, 反爬的token) 响应头中⼀些重要的内容: cookie: 本地字符串数据信息(⽤户登录信息, 反爬的token) 各种神奇的莫名其妙的字符串(这个需要经验了, ⼀般都是token 字样, 防⽌各种攻击和反爬） 请求方式： Get Query String Parameters Post form data pip清华园镜像https://mirrors.tuna.tsinghua.edu.cn/help/pypi/ requests实例案例1. 抓取搜狗搜索内容 kw = input(\"请输⼊你要搜索的内容:\") response = requests.get(f\"https://www.sogou.com/web?query={kw}\") # 发送get请求 # print(response.text) # 直接拿结果(⽂本) with open(\"sogou.html\", mode=\"w\", encoding=\"utf-8\") as f: f.write(response.text) 案例2.抓取百度翻译数据 # 准备参数 kw = input(\"请输⼊你要翻译的英语单词:\") dic = { \"kw\": kw # 这⾥要和抓包⼯具⾥的参数⼀致. } # 请注意百度翻译的sug这个url. 它是通过post⽅式进⾏提交的. 所以我们也要模拟post请求 resp = requests.post(\"https://fanyi.baidu.com/sug\",data=dic) # 返回值是json 那就可以直接解析成json resp_json = resp.json() # {'errno': 0, 'data': [{'k': 'Apple', 'v': 'n.苹果公司，原称苹果电脑公司'.... print(resp_json['data'][0]['v']) # 拿到返回字典中的内容 案例3: 抓取⾖瓣电影 url = 'https://movie.douban.com/j/chart/top_list' param = { 'type': '24', 'interval_id': '100:90', 'action':'', 'start': '0',#从库中的第⼏部电影去取 'limit': '20',#⼀次取出的个数 } headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36' } response = requests.get(url=url,params=param,headers=headers) list_data = response.json() fp = open('./douban.json','w',encoding='utf-8') json.dump(list_data,fp=fp,ensure_ascii=False) print('over!!!') XHR异步加载","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"springboot整合资源","date":"2022-06-21T13:01:02.022Z","updated":"2022-06-21T15:37:03.771Z","comments":true,"path":"2022/06/21/springboot-zheng-he-zi-yuan/","link":"","permalink":"https://lycode1202.github.io/2022/06/21/springboot-zheng-he-zi-yuan/","excerpt":"","text":"springboot整合servlet、filter、interceptorServlet方式一：xml注入package com.lee.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * springboot整合servlet的第一种方式： * 原来 * &lt;servlet> * &lt;servlet-name>firstServlet&lt;/servlet-name> * &lt;servlet-class>com.lee.FirstServlet&lt;/servlet-class> * &lt;/servlet> * &lt;servlet-mapping> * &lt;servlet-name>firstServlet&lt;/servlet-name> * &lt;url-pattern>/firstServlet&lt;/url-pattern> * &lt;/servlet-mapping> */ @WebServlet(name=\"firstServlet\",urlPatterns = \"/firstServlet\") public class FirstServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"firstServlet............\"); } } package com.lee; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; //该注解会扫描当前包和其子包下的 @WebServlet, //并在启动类启动的时候将其实例化 @ServletComponentScan @SpringBootApplication public class SpringbootApplicationServlet1 { public static void main(String[] args) { SpringApplication.run(SpringbootApplicationServlet1.class,args); } } 方式二：bean注入package com.lee.servlet; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class SecondServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"secondServlet....\"); } } package com.lee; import com.lee.servlet.SecondServlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; @SpringBootApplication public class SpringbootApplicationServlet2 { public static void main(String[] args) { SpringApplication.run(SpringbootApplicationServlet2.class,args); } //将scondServlet注册到servletRegistrationBean中 @Bean public ServletRegistrationBean secondServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(); bean.setServlet(new SecondServlet()); bean.addUrlMappings(\"/secondServlet\"); return bean; } } Filter方式一：xml注入package com.lee.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; /** * &lt;filter> * &lt;filter-name>FirstFilter&lt;/filter-name> * &lt;filter-class>com.lee.filter.FirstFilter&lt;/filter-class> * &lt;/filter> * &lt;filter-mapping> * &lt;filter-name>FirstFilter&lt;/filter-name> * &lt;url-patter>/firstServlet&lt;/url-patter> * &lt;/filter-mapping> */ //@WebFilter(filterName = \"firstFilter\",urlPatterns = {\"*.do\",\"*.action\"}) @WebFilter(filterName = \"firstFilter\",urlPatterns = \"/firstServlet\") public class FirstFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\" first filter init\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"enter first filter\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"leave first filter\"); } @Override public void destroy() { System.out.println(\" first filter destroy\"); } } package com.lee; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; //该注解会扫描当前包和其子包下的 @WebServlet @WebFilter等, //并在启动类启动的时候将其实例化 @ServletComponentScan @SpringBootApplication public class SpringbootApplicationFilter1 { public static void main(String[] args) { SpringApplication.run(SpringbootApplicationFilter1.class,args); } } 方式二：bean注入package com.lee.filter; import javax.servlet.*; import java.io.IOException; public class SecondFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\" second filter init\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"enter second filter\"); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"leave second filter\"); } @Override public void destroy() { System.out.println(\" second filter destroy\"); } } package com.lee; import com.lee.filter.SecondFilter; import com.lee.servlet.SecondServlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; @SpringBootApplication public class SpringbootApplicationFilter2 { public static void main(String[] args) { SpringApplication.run(SpringbootApplicationFilter2.class,args); } //将scondServlet注册到servletRegistrationBean中 @Bean public ServletRegistrationBean secondServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(); bean.setServlet(new SecondServlet()); bean.addUrlMappings(\"/secondServlet\"); return bean; } @Bean public FilterRegistrationBean secondFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new SecondFilter()); bean.addUrlPatterns(\"/secondServlet\"); return bean; } } interceptorpublic class MyInterceptor implements HandlerInterceptor { private final Logger logger = LoggerFactory.getLogger(this.getClass().getCanonicalName()); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception { logger.info(\"{}:在请求处理之前进行调用（Controller方法调用之前）\", this.getClass().getSimpleName()); return true;//只有返回true才会继续向下执行，返回false取消当前请求 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception { logger.info(\"{}:请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）\", this.getClass().getSimpleName()); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object o, Exception e) throws Exception { logger.info(\"{}:在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）\", this.getClass().getSimpleName()); } } @Configuration public class WebMvcConfig extends WebMvcConfigurerAdapter{ @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");//用于添加拦截规则 // 多个拦截器组成一个拦截器链 // excludePathPatterns 用户排除拦截 } }","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"QT编程","date":"2022-06-17T14:36:40.739Z","updated":"2023-04-15T03:46:27.774Z","comments":true,"path":"2022/06/17/qt-bian-cheng/","link":"","permalink":"https://lycode1202.github.io/2022/06/17/qt-bian-cheng/","excerpt":"","text":"QT教程QT框架——C++语言#include #include int main(int argc,char *argv[]){ QApplication app(argc,argv); //添加程序 return app.exec(); } QObject：所有能够处理Signal、slot和事件的Qt对象的基类 QApplication：对于一个应用程序是必类实体化是必须的，是QObject的子类 QWidget：是所有用户接口对象的基类，它继承了QObject类的属性。用户接口对象也称组件——QDialog、QMainWindow、QFrame直接继承QWidget类 Qt中采用信号和槽来实现通信 QT创建工程 Empty Qt4 Project 只创建“工程名.pro”的工程文件 需要手动创建，编辑输入纯源码程序 Qt4 Gui Application（Qt Gui应用) 自动创建“工程名.pro”文件 自动创建“类名.cpp“ 自动创建”类名.h“ 自动创建“main.cpp” 自动创建“类名.ui”，编译后生成“ui_类名.h” QtGui创建 QMainWindow类提供一个有菜单条、锚接窗口（工具条）、状态条的主应用程序窗口 QDialog类是对话框窗口的基类。最普通的顶级窗口 Qwidget类是所有用户界面对象的基类 QMainWindow、QDialog、QFrame直接继承Qwidget类 QT创建多窗口应用1、创建第一个窗口nGui2、右键nGUI — add new 3、编辑第一个dialog页面 4、添加槽函数 F4拖拽添加 利用+添加——但是如果要自定义槽函数，此种方法不可行 右键Go to Slot 要实现的功能：单击按钮使对话框关闭并发出Accepted信号功能 5、在主函数中编写逻辑#include \"ngui.h\" #include \"mydlg.h\" #include int main(int argc, char *argv[]) { QApplication a(argc, argv); nGui w; myDlg my1; if(my1.exec()==QDialog::Accepted){ w.show(); return a.exec(); } else{ return 0; } } 如果ui界面出现灰色，使用F3启用编辑 6、编写第二个widget界面 7、在widget.h中声明dialog的实体类myDlg my2; 8、在widget.cpp中的槽函数中展示实体类my2.show() 9、页面效果展示 QT实现登录对话框——无链接数据库1、创建登录窗口ui界面 2、建立对应的槽函数 退出 登录 void LoDlg::on_login_clicked() { //判断账户密码正确，trimmed用来防止输入用户名出现空格干扰 if(ui->user->text().trimmed()==\"qt\"&&ui->pwd->text()==\"123456\"){ accept(); } else{ QMessageBox::warning(this,\"WARNING\",\"username or password Error!\",QMessageBox::Yes); //如果密码和账户输入错误，则清空输入框并聚焦于第一个输入框 ui->user->clear(); ui->pwd->clear(); ui->user->setFocus(); } } 3、编写主函数#include \"login.h\" #include \"lodlg.h\" #include int main(int argc, char *argv[]) { QApplication a(argc, argv); login w; LoDlg login; //先弹出登录，登录成功跳转到主页面 if(login.exec()==QDialog::Accepted) { w.show(); return a.exec(); } else { return 0; } } 4、编写主页面ui界面 5、运行结果 QT操作sqlite数据库实现Slider1、设计ui界面 2、在pro工程文件中添加sqlQT += sql 3、创建头文件连接数据库、创建数据库——connection.h#ifndef CONNECT_H #define CONNECT_H #include #include static bool createConnection(){ //type of db :Qsqlite QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); //name of db :test db.setDatabaseName(\"test.db\"); //db can not open if(!db.open()){ return false; } //create a class named 'query' QSqlQuery query; //create a table named 'record' query.exec(\"create table record(id integer primary key autoincreament,temperature integer)\"); //insert data query.exec(\"insert into record values(1,1)\"); return true; } #endif // CONNECT_H 4、申明页面对应的槽函数——slider.h#ifndef SLIDER_H #define SLIDER_H #include QT_BEGIN_NAMESPACE namespace Ui { class slider; } QT_END_NAMESPACE class slider : public QMainWindow { Q_OBJECT public: slider(QWidget *parent = nullptr); ~slider(); private slots: void on_pushButton_clicked(); void on_verticalSlider_valueChanged(int value); private: Ui::slider *ui; }; #endif // SLIDER_H 5、编写槽函数逻辑和初始化代码——slider.cpp#include \"slider.h\" #include \"ui_slider.h\" #include \"connect.h\" QString lastvalue; slider::slider(QWidget *parent) : QMainWindow(parent) , ui(new Ui::slider) { ui->setupUi(this); QSqlQuery query; //select DESC query.exec(\"select * from record order by id DESC\"); //first record will be writen down,and then move until last one query.next(); //transform the type of 'temperature' into Integer int c = query.value(1).toInt(); //set initialized location about slider ui->verticalSlider->setValue(c); } slider::~slider() { delete ui; } void slider::on_verticalSlider_valueChanged(int value) { QString v = QString::number(value); ui->label->setText(v); lastvalue = v; } void slider::on_pushButton_clicked() { QSqlQuery query; QString sql = \"insert into record(temperature) values(\"+lastvalue +\")\"; query.exec(sql); qApp->quit(); } 6、完善主函数逻辑——main.cpp#include \"slider.h\" #include \"connect.h\" #include int main(int argc, char *argv[]) { QApplication a(argc, argv); if(!createConnection){ return 1; } slider w; w.show(); return a.exec(); } QT实现登录对话框——链接数据库1、设计页面——登录注册+LCD显示主页面 2、在pro工程文件中添加sql3、创建数据库头文件——connection.h#ifndef CONNECT_H #define CONNECT_H #include #include #include #include static bool createConnection() { QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setDatabaseName(\"data.db\"); if(!db.open()) { QMessageBox box; box.setText(\"open database failure!\"); box.exec(); return false; } QSqlQuery query; QString s=\"create table login(name varchar(10) primary key, passwd varchar(20))\"; qDebug() 4、申明页面对应的槽函数——login.h、mainwindow.h#ifndef LOGINDLG_H #define LOGINDLG_H #include #include namespace Ui { class loginDlg; } class loginDlg : public QDialog { Q_OBJECT public: explicit loginDlg(QWidget *parent = 0); ~loginDlg(); private slots: void on_loginBtn_clicked(); void on_registerBtn_clicked(); private: Ui::loginDlg *ui; QMessageBox box; }; #endif // LOGINDLG_H #ifndef MAINWINDOW_H #define MAINWINDOW_H #include #include namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); private slots: void on_exitBut_clicked(); void on_dial_valueChanged(int value); private: Ui::MainWindow *ui; QSqlQueryModel *querymodel; }; #endif // MAINWINDOW_H 5、完善login.cpp、main.cpp、mainwindow.cpp代码逻辑#include \"logindlg.h\" #include \"ui_logindlg.h\" #include #include loginDlg::loginDlg(QWidget *parent) : QDialog(parent), ui(new Ui::loginDlg) { ui->setupUi(this); ui-> pwdLineEdit-> setEchoMode(QLineEdit::Password); } loginDlg::~loginDlg() { delete ui; } //登录 void loginDlg::on_loginBtn_clicked() { QString user = ui->usrLineEdit->text(); QString pass = ui->pwdLineEdit->text(); if(user.isEmpty()||pass.isEmpty()) { box.setText(\"user or pass is empty\"); box.exec(); } else { QString s=QString(\"select * from login where name=='%1'\").arg(user); qDebug() usrLineEdit->text(); QString pass = ui->pwdLineEdit->text(); if(user.isEmpty()||pass.isEmpty()) { box.setText(\"user or pass is empty\"); box.exec(); } else { QString s = QString(\"insert into login values('%1','%2')\").arg(user).arg(pass); qDebug()usrLineEdit->clear();//清空用户名输入框 ui->pwdLineEdit->clear();//清空密码输入框 ui->usrLineEdit->setFocus();//将光标转到用户名输入框 } #include #include \"mainwindow.h\" #include \"logindlg.h\" #include \"connect.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); if(!createConnection()) { return false; } MainWindow w; loginDlg login; if(login.exec()==QDialog::Accepted) { w.show(); return a.exec(); } else return 0; } #include \"mainwindow.h\" #include \"ui_mainwindow.h\" #include #include MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui->setupUi(this); querymodel = new QSqlQueryModel(this); QString s = \"select * from lcd\"; querymodel->setQuery(s); ui->tableView->setModel(querymodel); QSqlQuery query; if(query.exec(s)) { query.last(); int c = query.value(1).toInt(); ui->dial->setValue(c); ui->lcdNumber->display(c); } } MainWindow::~MainWindow() { delete ui; } void MainWindow::on_exitBut_clicked() { int n = ui->dial->value(); QString s =QString(\"insert into lcd(n) values(%1)\").arg(n); qDebug()exit(); } void MainWindow::on_dial_valueChanged(int value) { ui->lcdNumber->display(value); }","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"嵌入式开发","date":"2022-06-04T15:59:20.047Z","updated":"2022-06-04T15:59:20.047Z","comments":true,"path":"2022/06/04/qian-ru-shi-kai-fa/","link":"","permalink":"https://lycode1202.github.io/2022/06/04/qian-ru-shi-kai-fa/","excerpt":"","text":"嵌入式开发环境配置编译器 gcc g++ clang cmake 需要一个CMakeLists.txt 创建Makefile文件 make","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"数据结构","date":"2022-06-03T08:51:40.599Z","updated":"2022-06-05T14:54:54.810Z","comments":true,"path":"2022/06/03/shu-ju-jie-gou/","link":"","permalink":"https://lycode1202.github.io/2022/06/03/shu-ju-jie-gou/","excerpt":"","text":"链表不带头结点单链表 使用头指针为全局变量 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;malloc.h> typedef int ElemType; //假设线性表中数据元素类型为整形 //单链表的表示与实现 //储存结构 struct Node { ElemType data; //存储数据 struct Node* next; //存储指针 }; typedef struct Node Node; //看似是一句废话，但是如果不写，每次引用结构体都要加一个struct，很繁琐 struct Node* head; //头指针：在这里声明是使head能够被全局调用，但是一般我们不这样使用 void Insert(int x){ Node* temp = (Node*)malloc(sizeof(Node)); temp->data = x; //常规做法就是这样，先创建一个结点使其指针next指向NULL //1、如果head为空，即temp是链表第一个结点，直接让head = temp即可 //2、如果head不为空，即temp不是链表第一个结点，根据头插法原则，需要让这个新插入的temp结点先指向head指向的结点，再让head指向自己 // temp->next = NULL; // if (head != NULL) // { // temp->next = head; // } //简化写法，每次都让temp指向head，因为如果你是第一个结点，指向head，即temp->next=NULL,所以过程都是一样的 temp->next=head; head=temp; } void Print(){ Node* temp = head; printf(\"List:\"); while (temp != NULL) { printf(\" %d\",temp->data); temp = temp->next; } printf(\"\\n\"); } int main(){ head = NULL; //初始化头指针 也可以写函数Init，操作相同 printf(\"how many numbers?\\n\"); int n,i,x; scanf(\"%d\",&amp;n); for (i = 0; i &lt; n; i++) { printf(\"please enter your num\\n\"); scanf(\"%d\",&amp;x); Insert(x); Print(); } } 使用头指针为局部变量 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;malloc.h> typedef int ElemType; //假设线性表中数据元素类型为整形 //单链表的表示与实现 //储存结构 struct Node { ElemType data; //存储数据 struct Node* next; //存储指针 }; typedef struct Node Node; //看似是一句废话，但是如果不写，每次引用结构体都要加一个struct，很繁琐 void Insert(Node** head,int x){ //这里为什么使用** ： 首先插入元素肯定是要在我定义的链表中进行操作，因此我传入了头指针的地址 //第一个*，是解析该地址对应的变量——此时的head表示一个指针 //第二个*，与Node组合表示 —— *head 是一个Node型的指针 Node* temp = (Node*)malloc(sizeof(Node)); temp->data = x; //常规做法就是这样，先创建一个结点使其指针next指向NULL //1、如果head为空，即temp是链表第一个结点，直接让head = temp即可 //2、如果head不为空，即temp不是链表第一个结点，根据头插法原则，需要让这个新插入的temp结点先指向head指向的结点，再让head指向自己 // temp->next = NULL; // if (*head != NULL) // { // temp->next = *head; // } //简化写法，每次都让temp指向head，因为如果你是第一个结点，指向head，即temp->next=NULL,所以过程都是一样的 temp->next=*head; *head=temp; } void Print(Node* head){ printf(\"List:\"); while (head != NULL) { printf(\" %d\",head->data); head = head->next; } printf(\"\\n\"); } int main(){ Node* head = NULL; //初始化头指针 也可以写函数Init，操作相同 printf(\"how many numbers?\\n\"); int n,i,x; scanf(\"%d\",&amp;n); for (i = 0; i &lt; n; i++) { printf(\"please enter your num\\n\"); scanf(\"%d\",&amp;x); Insert(&amp;head,x); Print(head); } } 实现指定位置插入操作 #include &lt;stdio.h> #include &lt;stdlib.h> typedef int ElemType; //假设线性表中数据元素类型为整形 //单链表的表示与实现 //储存结构 struct Node { ElemType data; //存储数据 struct Node* next; //存储指针 }; typedef struct Node Node; //看似是一句废话，但是如果不写，每次引用结构体都要加一个struct，很繁琐 struct Node* head; //头指针：在这里声明是使head能够被全局调用，但是一般我们不这样使用 //指定位置插入元素 void Insert_Index(int data,int n){ Node* temp1 = (Node*)malloc(sizeof(Node)); //新建插入的结点 temp1->data = data; temp1->next = NULL; if (n==1) //如果是第一个结点 { temp1->next = head; head = temp1; return; } if (n==2) { temp1->next = head->next; head->next = temp1; return; } Node* temp2 = head; //新建一个结点指针用来遍历链表 for (int i = 0; i &lt; n-2; i++) //要找到插入位置的前一个元素，即n-1，则temp = temp->next需要执行n-2次 { temp2 = temp2->next; } temp1->next = temp2->next; temp2->next = temp1; } void Print(){ Node* temp = head; printf(\"List:\"); while (temp != NULL) { printf(\" %d\",temp->data); temp = temp->next; } printf(\"\\n\"); } int main(){ head = NULL; Insert_Index(2,1); Insert_Index(3,2); Insert_Index(4,1); Insert_Index(5,2); Print(); } 实现指定位置删除操作 #include &lt;stdio.h> #include &lt;stdlib.h> typedef int ElemType; //假设线性表中数据元素类型为整形 //单链表的表示与实现 //储存结构 struct Node { ElemType data; //存储数据 struct Node *next; //存储指针 }; typedef struct Node Node; //看似是一句废话，但是如果不写，每次引用结构体都要加一个struct，很繁琐 struct Node *head; //头指针：在这里声明是使head能够被全局调用，但是一般我们不这样使用 void Insert(int x) { //这里为什么使用** ： 首先插入元素肯定是要在我定义的链表中进行操作，因此我传入了头指针的地址 //第一个*，是解析该地址对应的变量——此时的head表示一个指针 //第二个*，与Node组合表示 —— *head 是一个Node型的指针 Node *temp = (Node *)malloc(sizeof(Node)); temp->data = x; //常规做法就是这样，先创建一个结点使其指针next指向NULL // 1、如果head为空，即temp是链表第一个结点，直接让head = temp即可 // 2、如果head不为空，即temp不是链表第一个结点，根据头插法原则，需要让这个新插入的temp结点先指向head指向的结点，再让head指向自己 // temp->next = NULL; // if (head != NULL) // { // temp->next = head; // } //简化写法，每次都让temp指向head，因为如果你是第一个结点，指向head，即temp->next=NULL,所以过程都是一样的 temp->next = head; head = temp; } //指定位置删除 void Delete(int n) { Node *temp1 = head; if (n == 1) { head = temp1->next; free(temp1); return; } else { int i; for (i = 0; i &lt; n - 2; i++) temp1 = temp1->next; //使temp1指向 n-1 这个位置 Node *temp2 = temp1->next; temp1->next = temp2->next; free(temp2); // C++ 写法： delete temp2 } } void Print() { Node *temp = head; printf(\"List:\"); while (temp != NULL) { printf(\" %d\", temp->data); temp = temp->next; } printf(\"\\n\"); } int main() { head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); // List: 2,4,6,5 Print(); int n; printf(\"Enter a position\\n\"); scanf(\"%d\", &amp;n); Delete(n); Print(); } 逆转单链表 #include &lt;stdio.h> #include &lt;stdlib.h> typedef int ElemType; //假设线性表中数据元素类型为整形 //单链表的表示与实现 //储存结构 struct Node { ElemType data; //存储数据 struct Node *next; //存储指针 }; typedef struct Node Node; //看似是一句废话，但是如果不写，每次引用结构体都要加一个struct，很繁琐 struct Node *head; //头指针：在这里声明是使head能够被全局调用，但是一般我们不这样使用 void Insert(int x) { //这里为什么使用** ： 首先插入元素肯定是要在我定义的链表中进行操作，因此我传入了头指针的地址 //第一个*，是解析该地址对应的变量——此时的head表示一个指针 //第二个*，与Node组合表示 —— *head 是一个Node型的指针 Node *temp = (Node *)malloc(sizeof(Node)); temp->data = x; //常规做法就是这样，先创建一个结点使其指针next指向NULL // 1、如果head为空，即temp是链表第一个结点，直接让head = temp即可 // 2、如果head不为空，即temp不是链表第一个结点，根据头插法原则，需要让这个新插入的temp结点先指向head指向的结点，再让head指向自己 // temp->next = NULL; // if (head != NULL) // { // temp->next = head; // } //简化写法，每次都让temp指向head，因为如果你是第一个结点，指向head，即temp->next=NULL,所以过程都是一样的 temp->next = head; head = temp; } //方式一：逆转输出序列 void Reverse(){ Node *next,*prev,*current; current = head; prev = NULL; while (current != NULL) { next = current->next; current->next = prev; prev = current; current = next; } head = prev; } //递归打印输出单链表 void DPrint(Node *head){ //先递归再打印的输出顺序和先打印再递归的输出顺序不一样，可以实现逆转输出 if (head == NULL) return; DPrint(head->next); printf(\"%d \",head->data); } //递归逆转单链表 void DReverse(Node *p){ if (p->next == NULL) { head = p; return; } DReverse(p->next); Node *q = p->next; q->next = p; p->next = NULL; // p->next->next = p; } void Print() { Node *temp = head; printf(\"List:\"); while (temp != NULL) { printf(\" %d\", temp->data); temp = temp->next; } printf(\"\\n\"); } int main() { head = NULL; Insert(2); Insert(4); Insert(6); Insert(5); // List: 2,4,6,5 Print(); Reverse(); Print(); // DPrint(head); // DReverse(head); // Print(head); } 双向链表#include &lt;stdio.h> #include &lt;stdlib.h> #define ElemType int //双向链表结点类型定义 typedef struct Dnode { ElemType data; struct Dnode *prior, *next; } Dnode; //定义全局变量：头指针 struct Dnode *head; /* 知识点： 应用内存板块有：stack(栈)、heap(堆)、global/static(全局静态) 一个函数被调用时，会从栈上分配一些内存供该函数执行，该内存部分称为该函数的栈帧 该函数中所申明的所有局部变量都会存放到栈帧中去，在函数调用结束后，栈帧被回收 —— 栈中该元素的生命周期到此结束 即使我们返回了指向这个栈帧中变量位置的指针，但是栈帧已经不见了，知道位置毫无意义。 问题：为什么申明结点需要用到malloc呢？ 回答：malloc函数会在堆中申明一个空间用于存放结点， 重点：堆中申明的变量我们不能直接使用，访问堆中变量的唯一方法是通过指针，如果指针丢失，则该节点逻辑上也丢失了 因此我返回指向这个堆中变量位置的指针，可以通过该指针指向的位置来访问这个结点，逻辑上这个结点就申明成功了 */ //此函数动态的在heap(堆)中申明了一个node，执行完之后将指向node的指针返回，在heap中的变量，不会在函数执行后释放 Dnode *GetNewNode(int x) { Dnode *newNode = (Dnode *)malloc(sizeof(Dnode)); (*newNode).data = x; newNode->next = NULL; newNode->prior = NULL; return newNode; } //第二种写法是错误的，因为在函数体里面申明的变量存储到栈中的栈帧里，执行完函数堆栈会释放，其存储的变量也会相应释放 // Dnode* GetNewNode(int x) // { // Dnode newNode; // newNode.data = x; // newNode.next = NULL; // newNode.prior = NULL; // return &amp;newNode; // } void InsertAtHead(int x) { Dnode *newNode = GetNewNode(x); if (head == NULL) { head = newNode; return; } head->prior = newNode; newNode->next = head; head = newNode; } void Print() { Dnode* temp = head; printf(\"遍历：\"); while (temp != NULL) { printf(\"%d \", temp->data); temp = temp->next; } printf(\"\\n\"); } void ReversePrint() { Dnode* temp = head; if (head == NULL) { return; } while (temp->next != NULL) { temp = temp->next; } printf(\"遍历：\"); while (temp != NULL) { printf(\"%d \", temp->data); temp = temp->prior; } printf(\"\\n\"); } int main() { head = NULL; InsertAtHead(2); Print(); ReversePrint(); InsertAtHead(4); Print(); ReversePrint(); InsertAtHead(6); Print(); ReversePrint(); } 栈数组实现#include&lt;stdio.h> #define MAX_SIZE 101 int A[MAX_SIZE]; int top = -1; void Push(int x){ if (top == MAX_SIZE - 1) { printf(\"stack is full\\n\"); return; } top++; A[top]=x; } void Pop(){ if (top == - 1) { printf(\"stack is empty\\n\"); return; } top--; } int Top(){ return A[top]; } void Print(){ int i; printf(\"Stack: \"); for (i = 0; i &lt;= top; i++) { printf(\"%d \",A[i]); } printf(\"\\n\"); } int main(){ Push(2); Print(); Push(5); Print(); Push(10); Print(); Pop(); Print(); Push(12); Print(); } 单链表实现#include&lt;stdio.h> #include&lt;stdlib.h> struct Node { int data; struct Node* link; }; typedef struct Node Node; Node* top = NULL; void Push(int x){ Node* temp = (Node*)malloc(sizeof(Node)); temp->data = x; temp->link = top; top = temp; } void Pop(){ Node* temp; if (top == NULL) { return; } temp = top; top = top->link; free(temp); } int Top(){ return top->data; } void Print(){ printf(\"Stack:\\n\"); Node* p = top; while (p != NULL) { printf(\"%d \",p->data); p = p->link; } printf(\"\\n\"); } int main(){ Push(2); Print(); Push(5); Print(); Push(10); Print(); Pop(); Print(); Push(12); Print(); int A = Top(); printf(\"%d\",A); } 栈表逆置(C++)#include #include //stack标准库 #include #include using namespace std; // class Stack // { // private: // char A[101]; // int top; // public: // void Push(int x); // void Pop(); // int Top(); // bool IsEmpty(); // }; typedef struct Node { int data; Node* next; }Node; Node* head=NULL; void Push_Num(int x){ Node* temp = (Node*)malloc(sizeof(Node)); temp->data = x; temp->next = head; head = temp; } void Reverse(char C[],int n){ //C++中数组C[] 也可以写为 *C stack S; //压栈 for (int i = 0; i S; Node* temp = head; while (temp != NULL) { S.push(temp); temp = temp->next; } temp = S.top(); head = temp; //头指针指向栈顶元素，即原栈的栈底元素 S.pop(); while (!S.empty()) { temp->next=S.top(); //上一个栈顶元素 指向 弹出后的 下一个栈顶元素 S.pop(); temp=temp->next; } temp->next = NULL; } void Print(){ printf(\"Stack:\\n\"); Node* p = head; while (p != NULL) { printf(\"%d \",p->data); p = p->next; } printf(\"\\n\"); } int main(){ // char C[51]; // printf(\"Enter a String:\\n\"); // gets(C); // Reverse(C,strlen(C)); // printf(\"OutPut = %s\",C); Push_Num(2); Print(); Push_Num(5); Print(); Push_Num(10); Print(); Push_Num(12); Print(); Reverse(); Print(); }","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"Docker","date":"2022-05-31T13:40:42.774Z","updated":"2022-05-31T13:40:42.774Z","comments":true,"path":"2022/05/31/docker/","link":"","permalink":"https://lycode1202.github.io/2022/05/31/docker/","excerpt":"","text":"Docker实用篇1.初识Docker1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题： 依赖关系复杂，容易出现兼容性问题 开发、测试、生产环境有差异 例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。 1.1.2.Docker解决依赖兼容问题而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？ Docker为了解决依赖的兼容问题的，采用了两个手段： 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包 将每个应用放到一个隔离容器去运行，避免互相干扰 这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。 虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？ 1.1.3.Docker解决操作系统环境差异结构包括： 计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。 应用于计算机交互的流程如下： 1）应用调用操作系统应用（函数库），实现各种功能 2）系统函数库是对内核指令集的封装，会调用内核指令 3）内核指令操作计算机硬件 Docker如何解决不同系统环境的问题？ Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包 Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 Docker仅仅是封装函数库，并没有模拟完整的操作系统 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker1.4.1 卸载之前的Dockeryum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.4.2 安装Docker安装yum工具 yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 更新本地镜像源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum makecache fast 安装命令 yum -y install docker-ce 1.4.3 启动Dockersystemctl start docker Docker应用需要用到许多的端口，逐一设置防火墙，很麻烦，建议直接关闭（企业中是不允许的） # 关闭 systemctl stop firewalld #禁止开机自启 systemctl disable firewalld 1.4.4 配置加速镜像https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 2.Docker的基本操作2.1.镜像操作2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 2.1.2.镜像命令常见的镜像操作命令如图： 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： docker save --help 命令格式： docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： docker save -o nginx.tar nginx:latest 3）使用docker load加载镜像 先删除本地的nginx镜像： docker rmi nginx:latest 然后运行命令，加载本地文件： docker load -i nginx.tar 2.2.容器操作2.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 docer ps：查看所有运行的容器及状态 docker logs：查看容器日志 docker exec：进入容器执行命令 2.2.2.案例-创建并运行一个容器创建并运行nginx容器的命令： docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 2.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 2）进入nginx的HTML所在目录 /usr/share/nginx/html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： cd /usr/share/nginx/html 查看目录下文件： 3）修改index.html的内容 容器内没有vi命令，无法直接修改，我们用下面的命令来修改： sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's###g' index.html 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： 2.2.4.小结docker run命令的常见参数有哪些？ –name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 查看容器日志的命令： docker logs 添加 -f 参数可以持续查看日志 查看容器状态： docker ps docker ps -a 查看所有容器，包括已经停止的 2.3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 2.3.1.什么是数据卷数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了 2.3.2.数据集操作命令数据卷操作的基本语法如下： docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume 2.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 docker volume create html ② 查看所有数据 docker volume ls 结果： ③ 查看数据卷详细信息卷 docker volume inspect html 结果： 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 2.3.4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： docker run \\ --name mn \\ -v html:/root/html \\ -p 8080:80 nginx \\ 这里的-v就是挂载数据卷的命令： -v html:/root/htm ：把html数据卷挂载到容器内的/root/html这个目录中 2.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx ② 进入html数据卷所在位置，并修改HTML内容 # 查看html数据卷的位置 docker volume inspect html # 进入该目录 cd /var/lib/docker/volumes/html/_data # 修改文件 vi index.html 2.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录 直接挂载模式：宿主机目录 —&gt; 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 2）创建目录/tmp/mysql/data 3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf 4）去DockerHub查阅资料，创建并运行MySQL容器，要求： ① 挂载/tmp/mysql/data到mysql容器内数据存储目录 ② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件 ③ 设置MySQL密码 2.3.7.小结docker run的命令中通过 -v 参数挂载文件或目录到容器中： -v volume名称:容器内目录 -v 宿主机文件:容器内文 -v 宿主机目录:容器内目录 数据卷挂载与目录直接挂载的 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看 3.Dockerfile自定义镜像常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。 而要自定义镜像，就必须先了解镜像的结构才行。 3.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 3.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder 3.3.构建Java项目3.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 其中的内容如下： # 指定基础镜像 FROM ubuntu:16.04 # 配置环境变量，JDK的安装目录 ENV JAVA_DIR=/usr/local # 拷贝jdk和java项目的包 COPY ./jdk8.tar.gz $JAVA_DIR/ COPY ./docker-demo.jar /tmp/app.jar # 安装JDK RUN cd $JAVA_DIR \\ && tar -xf ./jdk8.tar.gz \\ && mv ./jdk1.8.0_144 ./java8 # 配置环境变量 ENV JAVA_HOME=$JAVA_DIR/java8 ENV PATH=$PATH:$JAVA_HOME/bin # 暴露端口 EXPOSE 8090 # 入口，java项目的启动命令 ENTRYPOINT java -jar /tmp/app.jar 步骤5：进入docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： docker build -t javaweb:1.0 . 最后访问 http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip 3.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 需求：基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将app.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： FROM java:8-alpine COPY ./app.jar /tmp/app.jar EXPOSE 8090 ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 ⑤ 使用docker run创建容器并运行 3.4.小结小结： Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 Dockerfile的第一行必须是FROM，从一个基础镜像来构建 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine 4.Docker-ComposeDocker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ 4.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： version:&amp;nbsp;\"3.8\" services: &amp;nbsp;&amp;nbsp;mysql: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;image:&amp;nbsp;mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volumes: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;\"/tmp/mysql/data:/var/lib/mysql\" &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;\"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\" &amp;nbsp;&amp;nbsp;web: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;build:&amp;nbsp;. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ports: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- \"8090:8090\" 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 4.2.安装DockerCompose参考课前资料 4.3.部署微服务集群需求：将之前学习的cloud-demo微服务集群利用DockerCompose部署 实现思路： ① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件 ② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名 ③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar ④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中 ⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署 4.3.1.compose文件查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录： 内容如下： version: \"3.2\" services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - \"8848:8848\" mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"$PWD/mysql/data:/var/lib/mysql\" - \"$PWD/mysql/conf:/etc/mysql/conf.d/\" userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - \"10010:10010\" 可以看到，其中包含5个service服务： nacos：作为注册中心和配置中心 image: nacos/nacos-server： 基于nacos/nacos-server镜像构建 environment：环境变量 MODE: standalone：单点模式启动 ports：端口映射，这里暴露了8848端口 mysql：数据库 image: mysql:5.7.25：镜像版本是mysql:5.7.25 environment：环境变量 MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123 volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据 userservice、orderservice、gateway：都是基于Dockerfile临时构建的 查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表： 查看微服务目录，可以看到都包含Dockerfile文件： 内容如下： FROM java:8-alpine COPY ./app.jar /tmp/app.jar ENTRYPOINT java -jar /tmp/app.jar 4.3.2.修改微服务配置因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。 如下所示： spring: datasource: url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false username: root password: 123 driver-class-name: com.mysql.jdbc.Driver application: name: orderservice cloud: nacos: server-addr: nacos:8848 # nacos服务地址 4.3.3.打包接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。 可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改： &lt;build> &lt;!-- 服务打包的最终名称 --> &lt;finalName>app&lt;/finalName> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> 打包后： 4.3.4.拷贝jar包到部署目录编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。 user-service： order-service： gateway： 4.3.5.部署最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。 上传到任意目录： 部署： 进入cloud-demo目录，然后运行下面的命令： docker-compose up -d 5.Docker镜像仓库5.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 5.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/ docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 ② 推送镜像 docker push 192.168.150.101:8080/nginx:1.0 ③ 拉取镜像 docker pull 192.168.150.101:8080/nginx:1.0","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"人工智能","date":"2022-05-15T00:57:53.878Z","updated":"2022-05-15T01:15:13.839Z","comments":true,"path":"2022/05/15/ren-gong-zhi-neng/","link":"","permalink":"https://lycode1202.github.io/2022/05/15/ren-gong-zhi-neng/","excerpt":"","text":"CV基础入门1、读取图片#导入模块 import cv2 as cv #读取图片 img=cv.imread('lena.jpg') #路径中不能有中文，否则加载图片失败 #显示图片 cv.imshow('read_img',img) #等待键盘输入 单位毫秒 传入0 则就是无限等待 cv.waitKey(3000) #释放内存 由于OpenCV底层是C++编写的 cv.destroyAllWindows() 2、灰度转化import cv2 as cv img=cv.imread('lena.jpg') cv.imshow('BGR_img',img) #将图片灰度转换 gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY) cv.imshow('gray_img',gray_img) #保存图片 cv.imwrite('gray_lena.jpg',gray_img) cv.waitKey(0) cv.destroyAllWindows() 3、修改图片尺寸pyimport cv2 as cv img=cv.imread('lena.jpg') cv.imshow('img',img) print('原来图片的形状',img.shape) # resize_img=cv.resize(img,dsize=(200,240)) resize_img=cv.resize(img,dsize=(600,560)) print('修改后图片的形状：',resize_img.shape) cv.imshow('resize_img',resize_img) # cv.waitKey(0) #只有输入q时候，退出 while True: if ord('q')==cv.waitKey(0): break cv.destroyAllWindows() 4、绘制选取框——矩形、圆import cv2 as cv img=cv.imread('lena.jpg') #左上角的坐标是(x,y) 矩形的宽度和高度(w,h) x,y,w,h=100,100,100,100 cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR #绘制圆center元组指圆点的坐标 radius：半径 x,y,r=200,200,100 cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2) #显示图片 cv.imshow('rectangle_img',img) cv.waitKey(0) cv.destroyAllWindows() 5、检测图片中的人脸import cv2 as cv def face_detect_demo(): #将图片灰度 gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) #加载特征数据 face_detector = cv.CascadeClassifier( 'E:/code_set/face_demo/facecode/haarcascade_frontalface_default.xml') faces = face_detector.detectMultiScale(gray) # 绘制选取框 for x,y,w,h in faces: print(x,y,w,h) cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2) cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2) #显示图片 cv.imshow('result',img) #加载图片 img=cv.imread('face3.jpg') #调用人脸检测方法 face_detect_demo() cv.waitKey(0) cv.destroyAllWindows() 6、检测视频中的人脸pyimport cv2 as cv def face_detect_demo(img): #将图片灰度 gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) #加载特征数据 face_detector = cv.CascadeClassifier( 'E:/soft/opencv/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml') faces = face_detector.detectMultiScale(gray) for x,y,w,h in faces: cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2) cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2) cv.imshow('result',img) #读取视频 cap = cv.VideoCapture('video.mp4') while True: flag,frame=cap.read() print('flag:',flag,'frame.shape:',frame.shape) if not flag: break face_detect_demo(frame) if ord('q') == cv.waitKey(10): break cv.destroyAllWindows() cap.release() 7、训练数据import os import cv2 import sys from PIL import Image import numpy as np def getImageAndLabels(path): facesSamples=[] ids=[] imagePaths=[os.path.join(path,f) for f in os.listdir(path)] #检测人脸 face_detector = cv2.CascadeClassifier( 'E:/code_set/face_demo/facecode/haarcascade_frontalface_default.xml') #遍历列表中的图片 for imagePath in imagePaths: #打开图片 PIL_img=Image.open(imagePath).convert('L') #将图像转换为数组 img_numpy=np.array(PIL_img,'uint8') faces = face_detector.detectMultiScale(img_numpy) #获取每张图片的id id=int(os.path.split(imagePath)[1].split('.')[0]) for x,y,w,h in faces: facesSamples.append(img_numpy[y:y+h,x:x+w]) ids.append(id) return facesSamples,ids if __name__ == '__main__': #图片路径 path='./data/jm/' #获取图像数组和id标签数组 faces,ids = getImageAndLabels(path) #获取训练对象 recognizer=cv2.face.LBPHFaceRecognizer_create() recognizer.train(faces,np.array(ids)) #保存文件 recognizer.write('trainer/trainer.yml') 8、人脸识别import cv2 import numpy as np import os #加载训练数据集文件 recogizer=cv2.face.LBPHFaceRecognizer_create() recogizer.read('trainer/trainer.yml') #准备识别的图片 img=cv2.imread('30.jpg') gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) face_detector = cv2.CascadeClassifier( 'E:/code_set/face_demo/facecode/haarcascade_frontalface_default.xml') faces = face_detector.detectMultiScale(gray) for x,y,w,h in faces: cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2) #人脸识别 id,confidence=recogizer.predict(gray[y:y+h,x:x+w]) print('标签id:',id,'置信评分：',confidence) cv2.imshow('result',img) cv2.waitKey(0) cv2.destroyAllWindows()","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"C语言基础","date":"2022-05-07T13:35:58.987Z","updated":"2023-04-15T03:50:46.385Z","comments":true,"path":"2022/05/07/c-yu-yan-ji-chu/","link":"","permalink":"https://lycode1202.github.io/2022/05/07/c-yu-yan-ji-chu/","excerpt":"","text":"C语言基础数据类型 输入输出 putchar 输出函数 getchar 输入函数 printf 格式输出函数 scanf 格式输入函数 运算符 所谓的“目”是指这个运算符参与运算的对象个数 单目运算符 ：自增++和 自减– 双目运算符 ：加法+、 减法-、 乘法*、 除法/、 求模% 长度(求字节)运算符 ： sizeof 逻辑运算符 ：逻辑与&amp;&amp;（双目）、逻辑或||（双目）、逻辑非！（单目） 三目运算符 ：表达式1?表达式2:表达式3 关系运算符 ：大于&gt;、小于&lt;、大于或等于&gt;=、小于或等于&lt;=、是否等于==、是否不等于!=","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"tkMapper整合使用","date":"2022-03-27T14:41:46.216Z","updated":"2022-04-01T01:22:00.733Z","comments":true,"path":"2022/03/27/tkmapper-zheng-he-shi-yong/","link":"","permalink":"https://lycode1202.github.io/2022/03/27/tkmapper-zheng-he-shi-yong/","excerpt":"","text":"一、tkMapper 实体类与数据表存在对应关系，并且是有规律的一一只要知道了数据表的结构，就能够生成实体类;所有实体的DAO接口中定义的方法也是有规律的，不同点就是实体类型不同 UserDAO public interface UserDAO extends GeneralDAO&lt;User>{ } GoodsDAO public interface GoodsDAO extends GeneralDAO&lt;Goods> { } GeneralDAO public interface GeneralDAO&lt;T>{ //通用方法 public int insert(T t); public T queryOneByPrimarykey(int i); ） 对于GeneralDAO接口定义的数据库操作方法因为使用了泛型，无需映射文件；对于UserDAO和GoodsDAO需要映射文件，所有DAO的相同操作的映射文件也是有规律可循的 UserMapper &lt;insert id=\"insert\"> insert into users(user_id,username) values(#{userId},#{username}） &lt;/insert> @Table(\"users\") public class User{ @Id @Column(\"user_id\") private int userId; @Column(\"username\") private String username; } GoodsMapper &lt;insert id=\"insert\"> insert into goods(goods_id,goodsrname) values(#{goodsId},#{goodsname}） &lt;/insert> @Table(\"product\") public class User{ @Id @Column(\"goods_id\") private int userId; @Column(\"goodsname\") private String username; } 二、tkMapper 基于MyBatis提供了很多第三方插件，这些插件通常可以完成数据操作方法的封装（GeneralDAO）、数据库逆向工程工作(根据数据表生成实体类、生成映射文件) MyBatis-plus tkMapper tkMapper就是一个MyBatis插件，是在MyBatis的基础上提供了很多工具，让开发变得简单，提高开发效率。 提供了针对单表通用的数据库操作方法 逆向工程（根据数据表生成实体类、dao接口、映射文件） 三、tkMapper整合3.1 基于SpringBoot完成MyBatis的整合3.2整合tkMapper3.2.1添加tkMapper的依赖&lt;dependency> &lt;groupId>tk.mybatis&lt;/groupId> &lt;artifactId>mapper-spring-boot-starter&lt;/artifactId> &lt;version>2.1.5&lt;/version> &lt;/dependency> 3.2.2修改启动类的@MapperScan 注解的包 为 tk .mybatis .spring.annotation.MapperScan import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication @MapperScan(\"com.qfedu.tkmapperdemo.dao\") public class TkmapperDemoApplication { public static void main(String[] args) { SpringApplication.run(TkmapperDemoApplication.class, args); } } 四、tkMapper使用4.1 创建DAO接口 tkMapper已经完成了对单表的通用操作的封装，封装在Mapper接口和MySqlMapper接口；因此如果我们要完成对单表的操作，只需自定义DAO接口继承Mapper接口和MySqIMapper接口 public interface UserDAO extends Mapper&lt;User>, MySqlMapper&lt;User> { } 4.2 tkMapper提供的方法@RunWith(SpringRunner.class) @SpringBootTest(classes = TkmapperDemoApplication.class) public class CategoryDAOTest { @Autowired private CategoryDAO categoryDAO; @Test public vold testInsert(){ Category category = new Category(日,\"测试类别3\",1,0,\"03.png\",\"xixi\",\"aaa.jpg\",\"black\"); //int i = categoryDAO.insert(category); int i = categoryDAO.insertUseGeneratedKeys(category); System.out.println(category.getCategoryId()); assertEquals(1,i); } @Test public void testUpdate(){ Category category = new Category(48,\"测试类别4\",1,0,\"04.png\",\"heihei\",\"aaa.jpg\",\"black\"); int i = categoryDAO.updateByPrimaryKey(category); //根据自定义条件修改，Example example就是封装条件的 // int i1 = categoryDAO.updateByExample( Example example); assertEquals(1,i); } @Test public void testDelete(){ int i = categoryDAO.deleteByPrimaryKey(48); // 根据条件删除 //int i1 = categoryDAO.deleteByExample(Example example); assertEquals(1,i); } @Test public void testSelect1(){ //查询所有 List&lt;Category> categories = categoryDAO.selectAll(); for (Category category: categories) { System.out.println(category); } } @Test public void testSelect2(){ //根据主键查询 Category category = categoryDAO.selectByPrimaryKey(47); System.out.println(category); } @Test public void testSelect4(){ //分页查询 int pageNum = 2; int pageSize = 10; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category> categories = categoryDAO.selectByRowBounds(new Category(), rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数 int i = categoryDAO.selectCount(new Category()); System.out.println(i); } @Test public void testSelect5(){ //带条件分页 //条件 Example example = new Example(Category.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo(\"categoryLevel\",1); //分页 int pageNum = 2; int pageSize = 3; int start = (pageNum-1)*pageSize; RowBounds rowBounds = new RowBounds(start,pageSize); List&lt;Category> categories = categoryDAO.selectByExampleAndRowBounds(example,rowBounds); for (Category category: categories) { System.out.println(category); } //查询总记录数（满足条件） int i = categoryDAO.selectCountByExample(example); System.out.println(i); } } 4.3 多表关联查询public void testSelect(){ //查询用户同时查询订单 Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andEqualTo( property.\"username\", value:\"zhangsan\"); //根据用户名查询用户 //1.先根据用户名查询用户信息 List&lt;User> users = userDAO.selectByExample(example); User user = users.get(0); //2.再根据用户id到订单表查询订单 Example example1 = new Example(Orders.class); Example.Criteria criteria1 = example1.createCriteria(); criteria1.andEqualTo(lproperty:\"userId\",user.getUserId()); List&lt;Orders> ordersList = orderDAO.selectByExample(example1); //3.将查询到订单集合设置到user user.setordersList(ordersList); System.out.println(user); } 也可以自定义sql语句进行关联查询 4.4 逆向工程——类似代码生成器 引入插件和依赖 在resource/gnerator目录下创建generatorConfig.xml &lt;!-- mysql的驱动版本要和pom文件中的mysql驱动版本一致 --> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.mybatis.generator&lt;/groupId> &lt;artifactId>mybatis-generator-maven-plugin&lt;/artifactId> &lt;version>1.3.5&lt;/version> &lt;configuration> &lt;configurationFile>${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile> &lt;/configuration> &lt;dependencies> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.27&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>tk.mybatis&lt;/groupId> &lt;artifactId>mapper&lt;/artifactId> &lt;version>4.0.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"> &lt;generatorConfiguration> &lt;!-- 引入数据库连接配置 --> &lt;!-- &lt;properties resource=\"jdbc.properties \"/>--> &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"> &lt;property name=\"beginningDelimiter\" value=\"`\"/> &lt;property name=\"endingDelimiter\" value=\"`\"/> &lt;!-- 配置 GeneralDAO --> &lt;plugin type=\"tk.mybatis.mapper.generator.MapperPlugin\"> &lt;property name=\"mappers\" value=\"com.ly.lymall.general.GeneralDAO\"/> &lt;/plugin> &lt;!-- 配置数据库连接--> &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mall\" userId=\"root\" password=\"123456\"> &lt;!-- connectionURL属性，防止乱码 --> &lt;property name=\"useUnicode\" value=\"true\"/> &lt;!-- connectionURL属性，防止乱码 --> &lt;property name=\"characterEncoding\" value=\"utf-8\"/> &lt;!-- connectionURL属性，防止报时间错误 --> &lt;property name=\"serverTimezone\" value=\"UTC\"/> &lt;!-- connectionURL属性，防止生成不同数据库同名表的代码 --> &lt;property name=\"nullCatalogMeansCurrent\" value=\"true\"/> &lt;/jdbcConnection> &lt;!-- 配置实体类存放路径 --> &lt;javaModelGenerator targetPackage=\"com.ly.lymall.entity\" targetProject=\"src/main/java\"/> &lt;!-- 配置 XML 存放路径 --> &lt;sqlMapGenerator targetPackage=\"/\" targetProject=\"src/main/resources/mappers\"/> &lt;!-- 配置 DAO 存放路径 --> &lt;javaClientGenerator targetPackage=\"com.ly.lymall.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\"/> &lt;!-- %代表要生成所有表 --> &lt;table tableName=\"%\">&lt;/table> &lt;/context> &lt;/generatorConfiguration> 将配置文件设置到逆向工程的maven插件 启动generator","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"Maven聚合工程","date":"2022-03-26T15:52:14.104Z","updated":"2022-03-27T02:29:40.547Z","comments":true,"path":"2022/03/26/maven-ju-he-gong-cheng/","link":"","permalink":"https://lycode1202.github.io/2022/03/26/maven-ju-he-gong-cheng/","excerpt":"","text":"Maven聚合工程一、概念 两个组件之间的互相调用必须要被打包在同一个jar包中 二、创建聚合工程2.1 创建父工程 创建一个maven工程 修改父工程的pom.xml文件，设置打包方式为pom &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>org.example&lt;/groupId> &lt;artifactId>Maven-pro&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>pom&lt;/packaging> &lt;/project> 父工程用于管理子工程，不进行业务实现 2.2 创建Module 创建新module子工程 子工程继承父工程 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;!-- 继承父工程 --> &lt;parent> &lt;artifactId>Maven-pro&lt;/artifactId> &lt;groupId>org.example&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>common&lt;/artifactId> &lt;/project> 父工程声明子module &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>org.example&lt;/groupId> &lt;artifactId>Maven-pro&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;modules> &lt;module>common&lt;/module> &lt;/modules> &lt;packaging>pom&lt;/packaging> &lt;/project> 子模块组件直接调用 易错点：一定要注意打包路径名称不要写错了，不然就会找不到包路径，报unkown的错误 三、Maven依赖继承3.1 依赖继承 在父工程pom中添加的依赖都会被子工程继承 子工程pom中单独添加的依赖，父工程无法引用 3.2 依赖版本管理 父工程pom中的dependencyManagement中定义的依赖，子工程若想使用，必须在pom中再次定义，但是不需要添加版本，版本默认被父工程的dependencyManagement管理","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"前后分离项目——商城","date":"2022-03-26T15:51:58.832Z","updated":"2022-04-15T04:21:31.671Z","comments":true,"path":"2022/03/26/qian-hou-fen-chi-xiang-mu-shang-cheng/","link":"","permalink":"https://lycode1202.github.io/2022/03/26/qian-hou-fen-chi-xiang-mu-shang-cheng/","excerpt":"","text":"一、架构的演变1.1 前后端分离 优点： 将对静态资源的访问和对接口的访问分离，Tomcat只负责数据的访问，可以支持更多的并发访问 1.2 集群 负载均衡：将对集群的并发请求按需分配到不同的服务器节点上 1.3 分布式 基于redis实现分布式锁 分布式数据库mycat redis集群 数据库中间件 ElasticSearch 消息中间件 RabbitMQ 1.4 微服务 原理：将原来一个应用中开发的多个模块进行拆分，单独开发和部署 保证可用性和性能 二、商城项目2.1 技术储备 （√）SpringBoot：进行SSM的整合 （√）Maven聚合工程：实现模块的复用 2.2 Maven聚合工程2.2.1 创建父工程lymall 创建一个maven工程，设置packing为pom 父工程继承 spring-boot-starter-parent &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.6.5&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.ly&lt;/groupId> &lt;artifactId>lymall&lt;/artifactId> &lt;version>2.0.1&lt;/version> &lt;modules> &lt;module>common&lt;/module> &lt;module>beans&lt;/module> &lt;module>mapper&lt;/module> &lt;module>service&lt;/module> &lt;module>api&lt;/module> &lt;/modules> &lt;packaging>pom&lt;/packaging> &lt;/project> 2.2.2 创建common工程 新建new module（Maven工程） 修改pom.xml，设置package为jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>lymall&lt;/artifactId> &lt;groupId>com.ly&lt;/groupId> &lt;version>2.0.1&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>common&lt;/artifactId> &lt;packaging>jar&lt;/packaging> &lt;/project> 2.2.3 创建beans工程 新建new module（Maven工程） 修改pom.xml，设置package为jar &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>lymall&lt;/artifactId> &lt;groupId>com.ly&lt;/groupId> &lt;version>2.0.1&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>beans&lt;/artifactId> &lt;packaging>jar&lt;/packaging> &lt;/project> 2.2.4 创建mapper工程 新建new module（Maven工程） 修改pom.xml，设置package为jar 在pom中依赖beans &lt;dependencies> &lt;dependency> &lt;groupId>com.ly&lt;/groupId> &lt;artifactId>beans&lt;/artifactId> &lt;version>2.0.1&lt;/version> &lt;/dependency> &lt;/dependencies> 2.2.5 创建service工程 新建new module（Maven工程） 修改pom.xml，设置package为jar 在pom中依赖mapper、common &lt;dependencies> &lt;dependency> &lt;groupId>com.ly&lt;/groupId> &lt;artifactId>common&lt;/artifactId> &lt;version>2.0.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.ly&lt;/groupId> &lt;artifactId>mapper&lt;/artifactId> &lt;version>2.0.1&lt;/version> &lt;/dependency> &lt;/dependencies> 2.2.6 创建api工程 新建new module（Spring Boot工程） 修改pom.xml，继承lymall &lt;parent> &lt;artifactId>lymall&lt;/artifactId> &lt;groupId>com.ly&lt;/groupId> &lt;version>2.0.1&lt;/version> &lt;/parent> 删除自己的groupId和version 将spring boot的依赖定义到父工程中 &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;configuration> &lt;excludes> &lt;exclude> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;/exclude> &lt;/excludes> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> 在父工程的modules中添加api 在api中依赖service com.ly service 2.0.1 2.3 依赖继承分析 如果将依赖添加到父工程的pom中，根据依赖的继承关系，所有的子工程都会继承父工程的依赖： 好处：当多个子工程都需要此种依赖时，无需重复引入 缺点：如果子工程不需要这个依赖，根据继承关系，将会被强制继承 2.4 依赖配置2.4.1 common子工程 lombok 2.4.2 beans子工程 Lombok 2.4.3 mapper子工程——MyBatis整合 在pom中新增Mybatis依赖 &lt;!--mysql驱动--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.27&lt;/version> &lt;/dependency> &lt;!--springboot-starter--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;version>2.6.3&lt;/version> &lt;/dependency> &lt;!--mybatis-starter--> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.2.0&lt;/version> &lt;/dependency> 在mapper工程下创建application.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: 123456 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.ly.lymall.entity 在api工程中的启动类通过 @MapperScan 声明dao包的路径 package com.ly; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\"com.ly.lymall.dao\") public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } 2.5 基于Springboot单元测试2.5.1 引入依赖 &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> 2.5.2 单元测试package com.ly.lymall.dao; import com.ly.ApiApplication; import com.ly.lymall.entity.User; import org.junit.jupiter.api.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import javax.annotation.Resource; /** * @author ly * @create 2022-03-27 12:22 */ @RunWith(SpringRunner.class) @SpringBootTest(classes = ApiApplication.class) public class UserDaoTest { @Resource private UserDao userDAO; @Test public void queryUserByName() { User user = userDAO.queryUserByName(\"Lucy\"); System.out.println(user); } } 2.6 整合Druid2.6.1 添加依赖 mapper工程中添加Druid的springboot-starter &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid-spring-boot-starter&lt;/artifactId> &lt;version>1.2.6&lt;/version> &lt;/dependency> 2.6.2 配置Druid 修改数据源配置application.yml spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: 123456 mybatis: mapper-locations: classpath:mappers/*Mapper.xml type-aliases-package: com.ly.lymall.entity 2.7 易错难点&lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;configuration> &lt;excludes> &lt;exclude> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;/exclude> &lt;/excludes> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> 该配置不应该被放置于parent工程中，这会导致子工程打包出现错误 这个插件的 repackage 目标会处理 jar 包，导致依赖它的模块无法使用它。在 parent 项目中使用它会导致每个子项目都执行了该目标，进而出现编译失败。 三、商城数据库设计3.1 数据库设计流程 根据项目功能分析数据实体（数据实体，就是应用系统中要存储的数据对象） 商品、订单、购物车、用户、评价、地址… 提取数据实体的数据项（数据对象的属性） 商品(商品id、商品名称、商品描述，特征) 地址(姓名、地址、电话…) 使用数据库设计三范式检查数据项是否合理 分析实体关系：E-R图 数据库建模（三线图）、建模工具 建库建表-SQL 3.2 数据库设计分析3.2.1 利用PDMan数据库建模 可视化创建数据表（数据表） 视图显示数据表之间的关系（关系图） 导出SQL指令（导出DDL脚本） 记录数据设计的版本（数据库模型版本的管理） 同步数据库模型到数据库（建立数据库链接即可） 3.2.2 SKU和SPU SPU，是 standard product unit，标准化产品单元，是商品信息聚合的最小单位，属性值、特性相同的商品就可以成为一个SPU。 SKU，全称 stock keeping unit，库存量单位。SKU 是用来定价和管理库存的。同款不同尺码不同色都是独立的 SKU，需要有独立的条形码和库存管理 四、商城业务流程设计 在企业项目开发中，当完成项目的需求分析、功能分析、数据库分析与设计之后，项目组按照项目中的功能进行开发任务的分配 编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定 4.1 登录业务 4.1.1 用户登录（示例）@GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\",defaultValue = \"111111\") String pwd){ return userService.checkLogin(name,pwd); } 接口说明：接收账号并进行校验，返回校验结果 请求URL：http://localhost:8080/user/login 请求方式：GET 请求参数： key 类型 是否必须 说明 username String 是 用户登录的账号 password String 否 用户登录的密码，有默认值 响应结果： key 响应 备注 code 响应状态码 1000 表示成功，1001表示失败 msg 响应提示信息 提示信息 data 响应数据 登录成功响应user信息，失败响应null 4.2 Swagger 前后端分离开发，后端需要编写接口说明文档，会耗费比较多的时间swagger是一个用于生成服务器接口的规范性文档、并且能够对接口进行测试的工具 4.2.1 作用 生成接口说明文档 对接口进行测试 4.2.2 整合 添加依赖（Swagger2\\Swagger ul) &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>2.9.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>2.9.2&lt;/version> &lt;/dependency> 在工程中创建SwaggerConfig package com.ly.lymall.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * @author ly * @create 2022-03-27 18:44 */ @Configuration @EnableSwagger2 public class SwaggerConfig { /*Docket 封装接口文档信息*/ @Bean public Docket getDocket(){ ApiInfoBuilder builder = new ApiInfoBuilder(); builder.title(\"《小一商城》后端接口文档\") .description(\"此文档详细说明了api接口规范\") .version(\"v 2.0.1\") .contact( new Contact(\"小李\",\"www.lycode.com\",\"2396446252@qq.com\")); ApiInfo apiInfo = builder.build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) //指定文档风格 .apiInfo(apiInfo) //指定生成的文档中的封面信息：文档标题、版本、作者 .select() .apis(RequestHandlerSelectors.basePackage(\"com.ly.lymall.controller\")) //指定响应控制器生成接口文档 .paths(PathSelectors.any()) .build(); return docket; } } 解决整合Swagger2 启动类报错 在启动类上添加 @EnableWebMvc 注解 解决Swagger2 404问题 package com.ly.lymall.config; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.util.List; /** * @author ly * @create 2022-03-27 19:47 */ @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/statics/**\").addResourceLocations(\"classpath:/statics/\"); // 解决 SWAGGER 404报错 registry.addResourceHandler(\"/swagger-ui.html\").addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); } @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) { } } 访问swagger页面 http://localhost:8080/swagger-ui.html 4.2.3 Swagger中的实用注解 @Api @ApiOperation @ApiImplicitParams 、 @ApiImplicitParam @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"String\",name = \"username\",value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"String\",name = \"password\",value = \"用户登录密码\",required = false,defaultValue = \"111111\") }) 效果图： @ApiModel、@ApiModelProperty 为接口参数对象添加注释 @ApiIgnore 添加此注解的方法将不能显示在swagger页面上 4.2.4 swagger-ui 插件 导入插件依赖 &lt;dependency> &lt;groupId>com.github.xiaoymin&lt;/groupId> &lt;artifactId>swagger-bootstrap-ui&lt;/artifactId> &lt;version>1.9.6&lt;/version> &lt;/dependency> 文档访问 http://ip:port/doc.html 被404 拦截——在WebConfig配置 // 解决 doc 404报错 registry.addResourceHandler(\"doc.html\").addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); 4.3 RESTful规范 前后端分离开发的项目中，前后端之间是接口进行请求和响应，后端向前端提供请求时就要对外暴露一个URL；URL的设计不能是随意的，需要遵从一定的设计规范——RESTful RESTful是一种Web api的标准，也就是一种url设计风格/规范 每个URL请求路径代表服务器上的唯一资源 传统的URL设计： http://localhost:8080/goods/delete？goodsId=1 商品1 http://localhost:8080/goods/delete7goodsId=2 商品2 RESTful设计： http://localhost:8088/goods/delete/1 商品1 http://localhost:8080/goods/delete/2 商品2 @RequestMapping(\"/delete/{gid}\") public ResultVO deleteGoods(@PathVariable(\"gid\") int goodsId){ return new ResultVO(10800,\"delete success\",null); } 使用不同的请求方式表示不同的操作 post （添加） put （修改） get （查询） delete（删除） option（预检） 接口响应的资源的表现形式采用JSON（或者XML） 在控制类或者每个接口方法添加@ResponseBody 注解将返回的对象格式为json 或者直接在控制器类使用@RestController 注解声明控制器 前端（Android\\ios\\pc）通过无状态的HTTP协议与后端接口进行交互 五、商城设计及实现——用户管理 创建Mapper、entity、mapperxml 创建实体类 @Data @NoArgsConstructor @AllArgsConstructor public class User { private int userId; private String username; private String password; private String nickname; private String realname; private String userImg; private String userMobile; private String userEmail; private String userSex; private Date userBirth; private Date userRegtime; private Date userModtime; } 创建DAO接口、定义操作方法 public interface UserDao { //用户注册 public int insertUser(User user); //根据用户名查询 public User queryUserByName(String name); } 创建DAO接口的mapper文件并完成配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.ly.lymall.dao.UserDao\"> &lt;insert id=\"insertUser\"> insert into Users(username,password,user_regtime,user_modtime) values(#{username},#{password},#{user_regtime},#{user_modtime}) &lt;/insert> &lt;resultMap id=\"userMap\" type=\"User\"> &lt;id column=\"user_id\" property=\"userId\"/> &lt;result column=\"username\" property=\"username\"/> &lt;result column=\"password\" property=\"password\"/> &lt;result column=\"nickname\" property=\"nickname\"/> &lt;result column=\"realname\" property=\"realname\"/> &lt;result column=\"user_img\" property=\"userImg\"/> &lt;result column=\"user_mobile\" property=\"userMobile\"/> &lt;result column=\"user_email\" property=\"userEmail\"/> &lt;result column=\"user_sex\" property=\"userSex\"/> &lt;result column=\"user_birth\" property=\"userBirth\"/> &lt;result column=\"user_regtime\" property=\"userRegtime\"/> &lt;result column=\"user_modtime\" property=\"userModtime\"/> &lt;/resultMap> &lt;select id=\"queryUserByName\"> select user_id,username,password,nickname,realname,user_img,user_mobile,user_email,user_sex,user_birth,user_regtime,user_modtime from users where username=#{name} &lt;/select> &lt;/mapper> 整合tkMapper——多表生成Service服务 创建service接口 public interface UserService { //用户登录 public ResultVO checkLogin(String name, String pwd); //用户注册 public ResultVO UserResgit(String name, String pwd); } 实现service功能 package com.ly.lymall.service.impl; import com.ly.lymall.dao.UserDao; import com.ly.lymall.entity.User; import com.ly.lymall.service.UserService; import com.ly.lymall.utils.MD5Utils; import com.ly.lymall.vo.ResultVO; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.Date; /** * @author ly * @create 2022-03-27 14:52 */ @Service @Scope(\"singleton\") public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public ResultVO checkLogin(String name, String pwd) { //根据账号查询用户信息 User user = userDao.queryUserByName(name); //判断 if (user == null) { //用户名不存在 return new ResultVO(1,\"用户名不存在\",null); }else { //对输入的pwd进行加密：md5 String md5Pwd = MD5Utils.md5(pwd); //使用加密后的密码 和 user中的密码进行匹配 if (md5Pwd.equals(user.getPassword())){ //验证成功 return new ResultVO(1000,\"登录成功\",user); }else { //密码错误 return new ResultVO(1002,\"密码错误\",null); } } } @Transactional public ResultVO UserResgit(String name, String pwd) { synchronized (this){ //线程锁，注册这个过程不能同时进行，会产生冲突 //1.根据用户名查找，这个用户有没有被注册 User user = userDao.queryUserByName(name); //2.如果没有被注册则进行保存操作 if (user == null) { String md5Pwd = MD5Utils.md5(pwd); user = new User(); user.setUsername(name); user.setPassword(md5Pwd); user.setUserModtime(new Date()); user.setUserRegtime(new Date()); int i = userDao.insertUser(user); if (i>0) { return new ResultVO(10000,\"注册成功！\",null); }else { return new ResultVO(10002,\"注册失败！\",null); } }else { return new ResultVO(10001,\"用户名已经被注册\",null); } } } } contoller视图层 创建controller package com.ly.lymall.controller; import com.ly.lymall.service.UserService; import com.ly.lymall.vo.ResultVO; import io.swagger.annotations.*; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; /** * @author ly * @create 2022-03-27 15:11 */ @RestController @RequestMapping(\"/user\") @Api(value = \"提供用户的登录和注册接口\",tags = \"用户管理\") public class UserController { @Resource private UserService userService; @ApiOperation(\"用户登录接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"String\",name = \"username\",value = \"用户登录账号\",required = true), @ApiImplicitParam(dataType = \"String\",name = \"password\",value = \"用户登录密码\",required = true) }) @GetMapping(\"/login\") public ResultVO login(@RequestParam(\"username\") String name, @RequestParam(value = \"password\") String pwd){ return userService.checkLogin(name,pwd); } @ApiOperation(\"用户注册接口\") @ApiImplicitParams({ @ApiImplicitParam(dataType = \"String\",name = \"username\",value = \"用户注册账号\",required = true), @ApiImplicitParam(dataType = \"String\",name = \"password\",value = \"用户注册密码\",required = true) }) @PostMapping(\"/regist\") public ResultVO regist(String username,String password){ return userService.UserResgit(username,password); } } 接口测试 基于swagger2进行测试 六、前端功能实现6.1 跨域问题 后端使用@CrossOrigin —— 设置响应头允许跨域访问 前端使用JSONP设置 6.2 前端页面间传值 cookie localStorage 七、前后端分离开发——用户认证7.1 单体开发session校验 在单体项目中，视图资源（页面）和接口（控制器）都在同一台服务器，用户的多次请求都是基于同一个会话（session），因此可以借助session来进行用户认证判断： 1.当用户登录成功之后，将用户信息存放到session 2.当用户再次访问受限资源时，验证session中是否存在用户信息，可以根据session有无用户信息来判断用户是否登录 7.2 前后端开发 7.2.1 token校验 后端 package com.ly.lymall.utils; import java.util.Base64; //base64 加密 解密 激活邮件的时候 为 邮箱地址 code验证码 进行加密 //当 回传回来后 进行邮箱地址 和 code 的解密 public class Base64Utils { //加密 public static String encode(String msg){ return Base64.getEncoder().encodeToString(msg.getBytes()); } //解密 public static String decode(String msg){ return new String(Base64.getDecoder().decode(msg)); } } package com.ly.lymall.controller; import com.ly.lymall.utils.Base64Utils; import com.ly.lymall.vo.ResStauts; import com.ly.lymall.vo.ResultVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/shopcar\") @CrossOrigin @Api(value = \"提供购物车功能呢接口\",tags = \"购物车管理\") public class ShopcarController { @GetMapping(\"/list\") @ApiImplicitParam(dataType = \"string\",name = \"token\",value = \"校验令牌\",required = true) public ResultVO listcar(String token){ //获取token，校验token if (token == null){ return new ResultVO(ResStauts.NO,\"请先登录！\",null); }else { String decode = Base64Utils.decode(token); if (decode.endsWith(\"Ly666\")){ //token校验成功 return new ResultVO(ResStauts.OK,\"success\",null); }else { return new ResultVO(ResStauts.NO,\"token不合法或已过期！\",null); } } } } //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） String token = Base64Utils.encode(name+\"Ly666\"); //验证成功 return new ResultVO(ResStauts.OK,token,users.get(0)); 前端 &lt;script type=\"text/javascript\"> var baseUrl = \"http://localhost:8080/\" var vm = new Vue({ el: '#container', data: { token: \"\", }, created(){ //进入页面时，需要查询购物车列表（访问购物车列表接口） this.token = getCookieValue(\"token\"); console.log(\"token:\"+this.token); axios({ method: \"get\", url: baseUrl + \"shopcar/list\", params: { token: this.token } }).then((res) => { console.log(res) }) }, }) &lt;/script> 7.2.2 JWT校验 如果按照上述规则生成token:1.简易的token生成规则安全性较差，如果要生成安全性很高的token对加密算法要求较高； 2.无法完成时效性的校验（登录过期） JWT: Json Web Token 依赖 &lt;dependency> &lt;groupId>com.auth0&lt;/groupId> &lt;artifactId>java-jwt&lt;/artifactId> &lt;version>3.18.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.jsonwebtoken&lt;/groupId> &lt;artifactId>jjwt&lt;/artifactId> &lt;version>0.9.1&lt;/version> &lt;/dependency> 生成token //如果登录验证成功，则需要生成令牌token（token就是按照特定规则生成的字符串） //使用jwt JwtBuilder builder = Jwts.builder(); HashMap&lt;String,Object> map = new HashMap&lt;>(); String token = builder.setSubject(name) //主题：token中携带的数据 .setIssuedAt(new Date()) //创建时间 .setId(users.get(0).getUserId() + \"\") //用户id为token的id .setClaims(map) //map中存放用户的角信息 .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000)) //设置社会过期时间 .signWith(SignatureAlgorithm.HS256, \"Ly666\") //设置加密方式和密码 .compact(); 7.2.3 拦截器 配置拦截器 import com.ly.lymall.interceptor.CheckLoginInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Autowired private CheckLoginInterceptor checkLoginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(checkLoginInterceptor) .addPathPatterns(\"/shopcar/**\") .addPathPatterns(\"/orders/**\") .excludePathPatterns(\"/user/**\"); } } 拦截器实现 package com.ly.lymall.interceptor; import com.fasterxml.jackson.databind.ObjectMapper; import com.ly.lymall.vo.ResStauts; import com.ly.lymall.vo.ResultVO; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jws; import io.jsonwebtoken.JwtParser; import io.jsonwebtoken.Jwts; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; /** * @author ly * @create 2022-04-08 12:42 */ @Component public class CheckLoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getParameter(\"token\"); if (token == null){ ResultVO vo = new ResultVO(ResStauts.NO, \"请先登录\", null); //登录提示 doResponse(response,vo); return false; }else { try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"Ly666\"); //如果token正确（密码正确，有效期内）正常执行，否则异常 Jws&lt;Claims> claimsJws = parser.parseClaimsJws(token); return true; } catch (Exception e) { return false; } } } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } 7.3 前端header传值 package com.ly.lymall.interceptor; import com.fasterxml.jackson.databind.ObjectMapper; import com.ly.lymall.vo.ResStauts; import com.ly.lymall.vo.ResultVO; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jws; import io.jsonwebtoken.JwtParser; import io.jsonwebtoken.Jwts; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; /** * @author ly * @create 2022-04-08 12:42 */ @Component public class CheckLoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String method = request.getMethod(); if (\"OPTIONS\".equalsIgnoreCase(method)){ //前端第一次请求时option，需要放行，TCP三次握手原理 return true; } String token = request.getHeader(\"token\"); System.out.println(\"-----------------------\"+token); if (token == null){ ResultVO vo = new ResultVO(ResStauts.NO, \"请先登录\", null); //登录提示 doResponse(response,vo); return false; }else { try { //验证token JwtParser parser = Jwts.parser(); parser.setSigningKey(\"Ly666\"); //如果token正确（密码正确，有效期内）正常执行，否则异常 Jws&lt;Claims> claimsJws = parser.parseClaimsJws(token); return true; } catch (Exception e) { ResultVO vo = new ResultVO(ResStauts.NO, \"登录过期\", null); doResponse(response,vo); } return false; } } private void doResponse(HttpServletResponse response,ResultVO resultVO) throws IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); String s = new ObjectMapper().writeValueAsString(resultVO); out.print(s); out.flush(); out.close(); } } axios({ method: \"get\", url: baseUrl + \"shopcar/list\", headers: { //header传值 token: this.token } })","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"Shiro框架","date":"2022-03-18T13:30:46.325Z","updated":"2022-06-21T15:37:47.618Z","comments":true,"path":"2022/03/18/shiro-kuang-jia/","link":"","permalink":"https://lycode1202.github.io/2022/03/18/shiro-kuang-jia/","excerpt":"","text":"Shiro框架Shiro功能的框架图 Authentication（认证）, Authorization（授权）, Session Management（会话管理）, Cryptography（加密）被 Shiro 框架的开发团队称之为应用安全的四大基石。 Authentication（认证）：用户身份识别，通常被称为用户“登录” Authorization（授权）：访问控制。比如某个用户是否具有某个操作的使用权限。 Session Management（会话管理）：特定于用户的会话管理,甚至在非web 或 EJB 应用程序。 Cryptography（加密）：在对数据源使用加密算法加密的同时，保证易于使用。 Shiro 架构包含三个主要的理念：Subject,SecurityManager和 Realm。 Subject：当前用户，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它–当前和软件交互的任何事件。 SecurityManager：管理所有Subject，SecurityManager 是 Shiro 架构的核心，配合内部安全组件共同组成安全伞。 Realms：用于进行权限信息的验证，需自己实现。Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个Realm 来实现认证（authentication）和/或授权（authorization）。 我们需要实现Realms的Authentication 和 Authorization。其中 Authentication 是用来验证用户身份，Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"前后端分离项目——个人博客","date":"2022-03-18T09:25:46.884Z","updated":"2022-06-21T16:38:02.280Z","comments":true,"path":"2022/03/18/qian-hou-duan-fen-chi-xiang-mu-ge-ren-bo-ke/","link":"","permalink":"https://lycode1202.github.io/2022/03/18/qian-hou-duan-fen-chi-xiang-mu-ge-ren-bo-ke/","excerpt":"","text":"前后端分离项目 原作者：吕一明 项目代码：https://github.com/MarkerHub/vueblog 项目视频：https://www.bilibili.com/video/BV1PQ4y1P7hZ/ Java后端接口开发1、前言技术栈： SpringBoot mybatis plus shiro lombok redis hibernate validatior jwt 导图： 2、新建Springboot项目开发工具与环境： idea mysql jdk 8 maven3.3.9 devtools：项目的热加载重启插件 lombok：简化代码的工具 3、整合mybatis plus第一步：导入jar包 pom中导入mybatis plus的jar包，因为后面会涉及到代码生成，所以我们还需要导入页面模板引擎，这里我们用的是freemarker。 &lt;!--mp--> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.2.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-freemarker&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;!--mp代码生成器--> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-generator&lt;/artifactId> &lt;version>3.2.0&lt;/version> &lt;/dependency> 第二步：然后去写配置文件 # DataSource Config spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai username: root password: admin mybatis-plus: mapper-locations: classpath*:/mapper/**Mapper.xml 上面除了配置数据库的信息，还配置了myabtis plus的mapper的xml文件的扫描路径，这一步不要忘记了。第三步：开启mapper接口扫描，添加分页插件 新建一个包：通过@mapperScan注解指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类。PaginationInterceptor是一个分页插件。 com.markerhub.config.MybatisPlusConfig @Configuration @EnableTransactionManagement @MapperScan(\"com.markerhub.mapper\") public class MybatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); return paginationInterceptor; } } 第四步：代码生成 如果你没再用其他插件，那么现在就已经可以使用mybatis plus了，官方给我们提供了一个代码生成器，然后我写上自己的参数之后，就可以直接根据数据库表信息生成entity、service、mapper等接口和实现类。 com.markerhub.CodeGenerator package com.ly; import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class CodeGenerator { public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\"); } public static void main(String[] args) { // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); // gc.setOutputDir(\"D:\\\\test\"); gc.setAuthor(\"ly\"); gc.setOpen(false); // gc.setSwagger2(true); 实体属性 Swagger2 注解 gc.setServiceName(\"%sService\"); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC\"); // dsc.setSchemaName(\"public\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(null); pc.setParent(\"com.ly\"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List&lt;FileOutConfig> focList = new ArrayList&lt;>(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(\"m_\"); mpg.setStrategy(strategy); mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); } } 在数据库中新建了一个user表： CREATE TABLE `m_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(64) DEFAULT NULL, `avatar` varchar(255) DEFAULT NULL, `email` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL, `status` int(5) NOT NULL, `created` datetime DEFAULT NULL, `last_login` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `UK_USERNAME` (`username`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `m_blog` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL, `title` varchar(255) NOT NULL, `description` varchar(255) NOT NULL, `content` longtext, `created` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP, `status` tinyint(4) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4; INSERT INTO `vueblog`.`m_user` (`id`, `username`, `avatar`, `email`, `password`, `status`, `created`, `last_login`) VALUES ('1', 'markerhub', 'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg', NULL, '96e79218965eb72c92a549dd5a330112', '0', '2020-04-20 10:44:01', NULL); 运行CodeGenerator的main方法，输入表名：m_user，m_blog表 在UserController中写个测试： @RestController @RequestMapping(\"/user\") public class UserController { @Autowired UserService userService; @GetMapping(\"/{id}\") public Object test(@PathVariable(\"id\") Long id) { return userService.getById(id); } } 4、统一结果封装这里我们用到了一个Result的类，这个用于我们的异步统一返回的结果封装。一般来说，结果里面有几个要素必要的 是否成功，可用code表示（如200表示成功，400表示异常） 结果消息 结果数据 所以可得到封装如下： com.markerhub.common.lang.Result package com.ly.common; import lombok.Data; import java.io.Serializable; /** * @author ly * 实现序列化，统一封装成result结果返回 * @create 2022-03-18 17:44 */ @Data public class Result implements Serializable { private String code; private String msg; private Object data; public static Result succ(String code,String msg,Object data) { Result m = new Result(); m.setCode(code); m.setData(data); m.setMsg(msg); return m; } public static Result fail(String code,String msg,Object data) { Result m = new Result(); m.setCode(code); m.setData(data); m.setMsg(msg); return m; } public static Result succ(Object data) { return succ(\"200\",\"操作成功\",data); } public static Result succ(String mess, Object data) { return succ(\"200\",mess,data); } public static Result fail(String mess) { return fail(\"400\",mess,null); } public static Result fail(String mess, Object data) { return fail(\"400\",mess,data); } } 5、整合shiro+jwt，并会话共享JSON Web Token（JWT）是一个非常轻巧的规范。利用一定的编码生成 Token，并在 Token 中加入一些非敏感信息，将其传递。 一个完整的 Token：用 . 分隔数据 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM 考虑到后面可能需要做集群、负载均衡等，所以就需要会话共享，而shiro的缓存和会话信息，我们一般考虑使用redis来存储这些数据，所以，我们不仅仅需要整合shiro，同时也需要整合redis。在开源的项目中，我们找到了一个starter可以快速整合shiro-redis，配置简单，这里也推荐大家使用。 而因为我们需要做的是前后端分离项目的骨架，所以一般我们会采用token或者jwt作为跨域身份验证解决方案。所以整合shiro的过程中，我们需要引入jwt的身份验证过程。 那么我们就开始整合： 我们使用一个shiro-redis-spring-boot-starter的jar包，具体教程可以看官方文档：https://github.com/alexxiyang/shiro-redis/blob/master/docs/README.md#spring-boot-starter 第一步：导入shiro-redis的starter包：还有jwt的工具包，以及为了简化开发，我引入了hutool工具包。 &lt;dependency> &lt;groupId>org.crazycake&lt;/groupId> &lt;artifactId>shiro-redis-spring-boot-starter&lt;/artifactId> &lt;version>3.2.1&lt;/version> &lt;/dependency> &lt;!-- hutool工具类--> &lt;dependency> &lt;groupId>cn.hutool&lt;/groupId> &lt;artifactId>hutool-all&lt;/artifactId> &lt;version>5.3.3&lt;/version> &lt;/dependency> &lt;!-- jwt --> &lt;dependency> &lt;groupId>io.jsonwebtoken&lt;/groupId> &lt;artifactId>jjwt&lt;/artifactId> &lt;version>0.9.1&lt;/version> &lt;/dependency> 第二步：编写配置： ShiroConfig com.markerhub.config.ShiroConfig package com.ly.config; import com.ly.shiro.AccountRealm; import com.ly.shiro.JwtFilter; import org.apache.shiro.mgt.DefaultSessionStorageEvaluator; import org.apache.shiro.mgt.DefaultSubjectDAO; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.session.mgt.SessionManager; import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition; import org.apache.shiro.spring.web.config.ShiroFilterChainDefinition; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.apache.shiro.web.session.mgt.DefaultWebSessionManager; import org.crazycake.shiro.RedisCacheManager; import org.crazycake.shiro.RedisSessionDAO; import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; @Configuration public class shiroConfig { @Autowired JwtFilter jwtFilter; @Bean public SessionManager sessionManager(RedisSessionDAO redisSessionDAO) { DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); sessionManager.setSessionDAO(redisSessionDAO); return sessionManager; } @Bean public DefaultWebSecurityManager securityManager(AccountRealm accountRealm, SessionManager sessionManager, RedisCacheManager redisCacheManager) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm); securityManager.setSessionManager(sessionManager); securityManager.setCacheManager(redisCacheManager); /* * 关闭shiro自带的session，详情见文档 */ DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator(); defaultSessionStorageEvaluator.setSessionStorageEnabled(false); subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator); securityManager.setSubjectDAO(subjectDAO); return securityManager; } @Bean public ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition(); Map&lt;String, String> filterMap = new LinkedHashMap&lt;>(); filterMap.put(\"/**\", \"jwt\"); // 主要通过注解方式校验权限 chainDefinition.addPathDefinitions(filterMap); return chainDefinition; } @Bean(\"shiroFilterFactoryBean\") public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager, ShiroFilterChainDefinition shiroFilterChainDefinition) { ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean(); shiroFilter.setSecurityManager(securityManager); Map&lt;String, Filter> filters = new HashMap&lt;>(); filters.put(\"jwt\", jwtFilter); shiroFilter.setFilters(filters); Map&lt;String, String> filterMap = shiroFilterChainDefinition.getFilterChainMap(); shiroFilter.setFilterChainDefinitionMap(filterMap); return shiroFilter; } // 开启注解代理（默认好像已经开启，可以不要） @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager){ AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator(); return creator; } } 上面ShiroConfig，我们主要做了几件事情： 引入RedisSessionDAO和RedisCacheManager，为了解决shiro的权限数据和会话信息能保存到redis中，实现会话共享。 重写了SessionManager和DefaultWebSecurityManager，同时在DefaultWebSecurityManager中为了关闭shiro自带的session方式，我们需要设置为false，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。 在ShiroFilterChainDefinition中，我们不再通过编码形式拦截Controller访问路径，而是所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。 那么，接下来，我们聊聊ShiroConfig中出现的AccountRealm，还有JwtFilter。 AccountRealmAccountRealm是shiro进行登录或者权限校验的逻辑所在，算是核心了，我们需要重写3个方法，分别是 supports：为了让realm支持jwt的凭证校验 doGetAuthorizationInfo：权限校验 doGetAuthenticationInfo：登录认证校验 我们先来总体看看AccountRealm的代码，然后逐个分析： com.markerhub.shiro.AccountRealm @Slf4j @Component public class AccountRealm extends AuthorizingRealm { @Autowired JwtUtils jwtUtils; @Autowired UserService userService; @Override public boolean supports(AuthenticationToken token) { return token instanceof JwtToken; } @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { return null; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { JwtToken jwt = (JwtToken) token; log.info(\"jwt----------------->{}\", jwt); String userId = jwtUtils.getClaimByToken((String) jwt.getPrincipal()).getSubject(); User user = userService.getById(Long.parseLong(userId)); if(user == null) { throw new UnknownAccountException(\"账户不存在！\"); } if(user.getStatus() == -1) { throw new LockedAccountException(\"账户已被锁定！\"); } AccountProfile profile = new AccountProfile(); BeanUtil.copyProperties(user, profile); log.info(\"profile----------------->{}\", profile.toString()); return new SimpleAuthenticationInfo(profile, jwt.getCredentials(), getName()); } } 其实主要就是doGetAuthenticationInfo登录认证这个方法，可以看到我们通过jwt获取到用户信息，判断用户的状态，最后异常就抛出对应的异常信息，否者封装成SimpleAuthenticationInfo返回给shiro。接下来我们逐步分析里面出现的新类： 1、shiro默认supports的是UsernamePasswordToken，而我们现在采用了jwt的方式，所以这里我们自定义一个JwtToken，来完成shiro的supports方法。 JwtToken com.markerhub.shiro.JwtToken public class JwtToken implements AuthenticationToken { private String token; public JwtToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return token; } } 2、JwtUtils是个生成和校验jwt的工具类，其中有些jwt相关的密钥信息是从项目配置文件中配置的： @Component @ConfigurationProperties(prefix = \"markerhub.jwt\") public class JwtUtils { private String secret; private long expire; private String header; /** * 生成jwt token */ public String generateToken(long userId) { ... } // 获取jwt的信息 public Claims getClaimByToken(String token) { ... } /** * token是否过期 * @return true：过期 */ public boolean isTokenExpired(Date expiration) { return expiration.before(new Date()); } } 3、而在AccountRealm我们还用到了AccountProfile，这是为了登录成功之后返回的一个用户信息的载体， AccountProfile com.markerhub.shiro.AccountProfile @Data public class AccountProfile implements Serializable { private Long id; private String username; private String avatar; } 第三步，ok，基本的校验的路线完成之后，我们需要少量的基本信息配置： shiro-redis: enabled: true redis-manager: host: 127.0.0.1:6379 markerhub: jwt: # 加密秘钥 secret: f4e2e52034348f86b67cde581c0f9eb5 # token有效时长，7天，单位秒 expire: 604800 header: token 第四步：另外，如果你项目有使用spring-boot-devtools，需要添加一个配置文件，在resources目录下新建文件夹META-INF，然后新建文件spring-devtools.properties，这样热重启时候才不会报错。 resources/META-INF/spring-devtools.properties restart.include.shiro-redis=/shiro-[\\\\w-\\\\.]+jar JwtFilter第五步：定义jwt的过滤器JwtFilter。 这个过滤器是我们的重点，这里我们继承的是Shiro内置的AuthenticatingFilter，一个可以内置了可以自动登录方法的的过滤器，有些同学继承BasicHttpAuthenticationFilter也是可以的。 我们需要重写几个方法： createToken：实现登录，我们需要生成我们自定义支持的JwtToken onAccessDenied：拦截校验，当头部没有Authorization时候，我们直接通过，不需要自动登录；当带有的时候，首先我们校验jwt的有效性，没问题我们就直接执行executeLogin方法实现自动登录 onLoginFailure：登录异常时候进入的方法，我们直接把异常信息封装然后抛出 preHandle：拦截器的前置拦截，因为我们是前后端分析项目，项目中除了需要跨域全局配置之外，我们再拦截器中也需要提供跨域支持。这样，拦截器才不会在进入Controller之前就被限制了。 下面我们看看总体的代码： com.markerhub.shiro.JwtFilter @Component public class JwtFilter extends AuthenticatingFilter { @Autowired JwtUtils jwtUtils; @Override protected AuthenticationToken createToken(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception { // 获取 token HttpServletRequest request = (HttpServletRequest) servletRequest; String jwt = request.getHeader(\"Authorization\"); if(StringUtils.isEmpty(jwt)){ return null; } return new JwtToken(jwt); } @Override protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception { HttpServletRequest request = (HttpServletRequest) servletRequest; String token = request.getHeader(\"Authorization\"); if(StringUtils.isEmpty(token)) { return true; } else { // 判断是否已过期 Claims claim = jwtUtils.getClaimByToken(token); if(claim == null || jwtUtils.isTokenExpired(claim.getExpiration())) { throw new ExpiredCredentialsException(\"token已失效，请重新登录！\"); } } // 执行自动登录 return executeLogin(servletRequest, servletResponse); } @Override protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) { HttpServletResponse httpResponse = (HttpServletResponse) response; try { //处理登录失败的异常 Throwable throwable = e.getCause() == null ? e : e.getCause(); Result r = Result.fail(throwable.getMessage()); String json = JSONUtil.toJsonStr(r); httpResponse.getWriter().print(json); } catch (IOException e1) { } return false; } /** * 对跨域提供支持 */ @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = WebUtils.toHttp(request); HttpServletResponse httpServletResponse = WebUtils.toHttp(response); httpServletResponse.setHeader(\"Access-control-Allow-Origin\", httpServletRequest.getHeader(\"Origin\")); httpServletResponse.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,PUT,DELETE\"); httpServletResponse.setHeader(\"Access-Control-Allow-Headers\", httpServletRequest.getHeader(\"Access-Control-Request-Headers\")); // 跨域时会首先发送一个OPTIONS请求，这里我们给OPTIONS请求直接返回正常状态 if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) { httpServletResponse.setStatus(org.springframework.http.HttpStatus.OK.value()); return false; } return super.preHandle(request, response); } } 那么到这里，我们的shiro就已经完成整合进来了，并且使用了jwt进行身份校验。 6、异常处理有时候不可避免服务器报错的情况，如果不配置异常处理机制，就会默认返回tomcat或者nginx的5XX页面，对普通用户来说，不太友好，用户也不懂什么情况。这时候需要我们程序员设计返回一个友好简单的格式给前端。 处理办法如下：通过使用@ControllerAdvice来进行统一异常处理，@ExceptionHandler(value = RuntimeException.class)来指定捕获的Exception各个类型异常 ，这个异常的处理，是全局的，所有类似的异常，都会跑到这个地方处理。 com.markerhub.common.exception.GlobalExceptionHandler 步骤二、定义全局异常处理，@ControllerAdvice表示定义全局控制器异常处理，@ExceptionHandler表示针对性异常处理，可对每种异常针对性处理。 /** * 全局异常处理 */ @Slf4j @RestControllerAdvice public class GlobalExcepitonHandler { // 捕捉shiro的异常 @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(ShiroException.class) public Result handle401(ShiroException e) { return Result.fail(401, e.getMessage(), null); } /** * 处理Assert的异常 */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = IllegalArgumentException.class) public Result handler(IllegalArgumentException e) throws IOException { log.error(\"Assert异常:-------------->{}\",e.getMessage()); return Result.fail(e.getMessage()); } /** * @Validated 校验错误异常处理 */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = MethodArgumentNotValidException.class) public Result handler(MethodArgumentNotValidException e) throws IOException { log.error(\"运行时异常:-------------->\",e); BindingResult bindingResult = e.getBindingResult(); ObjectError objectError = bindingResult.getAllErrors().stream().findFirst().get(); return Result.fail(objectError.getDefaultMessage()); } @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(value = RuntimeException.class) public Result handler(RuntimeException e) throws IOException { log.error(\"运行时异常:-------------->\",e); return Result.fail(e.getMessage()); } } 上面我们捕捉了几个异常： ShiroException：shiro抛出的异常，比如没有权限，用户登录异常 IllegalArgumentException：处理Assert的异常 MethodArgumentNotValidException：处理实体校验的异常 RuntimeException：捕捉其他异常 7、实体校验当我们表单数据提交的时候，前端的校验我们可以使用一些类似于jQuery Validate等js插件实现，而后端我们可以使用Hibernate validatior来做校验。 我们使用springboot框架作为基础，那么就已经自动集成了Hibernate validatior。 那么用起来啥样子的呢？ 第一步：首先在实体的属性上添加对应的校验规则，比如： @TableName(\"m_user\") public class User implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \"id\", type = IdType.AUTO) private Long id; @NotBlank(message = \"昵称不能为空\") private String username; @NotBlank(message = \"邮箱不能为空\") @Email(message = \"邮箱格式不正确\") private String email; ... } 第二步 ：这里我们使用@Validated注解方式，如果实体不符合要求，系统会抛出异常，那么我们的异常处理中就捕获到MethodArgumentNotValidException。 com.markerhub.controller.UserController /** * 测试实体校验 * @param user * @return */ @PostMapping(\"/save\") public Object testUser(@Validated @RequestBody User user) { return user.toString(); } 8、跨域问题因为是前后端分析，所以跨域问题是避免不了的，我们直接在后台进行全局跨域处理： com.markerhub.config.CorsConfig package com.ly.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 解决跨域问题 */ @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOriginPatterns(\"*\") .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\") .allowCredentials(true) .maxAge(3600) .allowedHeaders(\"*\"); } } ok，因为我们系统开发的接口比较简单，所以我就不集成swagger2啦，也比较简单而已。下面我们就直接进入我们的正题，进行编写登录接口。 9、登录接口开发登录的逻辑其实很简答，只需要接受账号密码，然后把用户的id生成jwt，返回给前段，为了后续的jwt的延期，所以我们把jwt放在header上。具体代码如下： com.markerhub.controller.AccountController @RestController public class AccountController { @Autowired JwtUtils jwtUtils; @Autowired UserService userService; /** * 默认账号密码：markerhub / 111111 * */ @CrossOrigin @PostMapping(\"/login\") public Result login(@Validated @RequestBody LoginDto loginDto, HttpServletResponse response) { User user = userService.getOne(new QueryWrapper&lt;User>().eq(\"username\", loginDto.getUsername())); Assert.notNull(user, \"用户不存在\"); if(!user.getPassword().equals(SecureUtil.md5(loginDto.getPassword()))) { return Result.fail(\"密码错误！\"); } String jwt = jwtUtils.generateToken(user.getId()); response.setHeader(\"Authorization\", jwt); response.setHeader(\"Access-Control-Expose-Headers\", \"Authorization\"); // 用户可以另一个接口 return Result.succ(MapUtil.builder() .put(\"id\", user.getId()) .put(\"username\", user.getUsername()) .put(\"avatar\", user.getAvatar()) .put(\"email\", user.getEmail()) .map() ); } // 退出 @GetMapping(\"/logout\") @RequiresAuthentication public Result logout() { SecurityUtils.getSubject().logout(); return Result.succ(null); } } 10、博客接口开发我们的骨架已经完成，接下来，我们就可以添加我们的业务接口了，下面我以一个简单的博客列表、博客详情页为例子开发： com.markerhub.utils.ShiroUtils package com.ly.util; import com.ly.shiro.AccountProfile; import org.apache.shiro.SecurityUtils; public class ShiroUtils { public static AccountProfile getProfile(){ return (AccountProfile) SecurityUtils.getSubject().getPrincipal(); } } com.markerhub.controller.BlogController package com.ly.controller; import cn.hutool.core.bean.BeanUtil; import cn.hutool.core.lang.Assert; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.ly.common.Result; import com.ly.entity.Blog; import com.ly.service.BlogService; import com.ly.util.ShiroUtils; import org.apache.shiro.authz.annotation.RequiresAuthentication; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; import java.time.LocalDateTime; @RestController public class BlogController { @Autowired BlogService blogService; @GetMapping(\"/blogs\") public Result blogs(Integer currentPage) { if(currentPage == null || currentPage &lt; 1) currentPage = 1; Page page = new Page(currentPage, 5); IPage pageData = blogService.page(page, new QueryWrapper&lt;Blog>().orderByDesc(\"created\")); return Result.succ(pageData); } @GetMapping(\"/blog/{id}\") public Result detail(@PathVariable(name = \"id\") Long id) { Blog blog = blogService.getById(id); Assert.notNull(blog, \"该博客已删除！\"); return Result.succ(blog); } @RequiresAuthentication //需要登录之后才能访问的接口，其他需要权限的接口可以添加shiro的相关注解。 @PostMapping(\"/blog/edit\") public Result edit(@Validated @RequestBody Blog blog) { System.out.println(blog.toString()); Blog temp = null; if(blog.getId() != null) { temp = blogService.getById(blog.getId()); Assert.isTrue(temp.getUserId().equals(ShiroUtils.getProfile().getId()), \"没有权限编辑\"); } else { temp = new Blog(); temp.setUserId(ShiroUtils.getProfile().getId()); temp.setCreated(LocalDateTime.now()); temp.setStatus(0); } BeanUtil.copyProperties(blog, temp, \"id\", \"userId\", \"created\", \"status\"); blogService.saveOrUpdate(temp); return Result.succ(\"操作成功\", null); } } Vue前端页面开发1、前言技术栈： vue element-ui axios mavon-editor markdown-it github-markdown-css 2、环境准备1、首先我们上node.js官网(https://nodejs.org/zh-cn/)，下载最新的长期版本，直接运行安装完成后检查下版本信息 2、接下来，我们安装vue的环境 # 安装淘宝npm npm install -g cnpm --registry=https://registry.npm.taobao.org # vue-cli 安装依赖包 cnpm install --g vue-cli 3、新建项目# 在项目文件夹下，打开cmd vue create vueblog-vue ├── README.md 项目介绍 ├── index.html 入口页面 ├── build 构建脚本目录 │ ├── build-server.js 运行本地构建服务器，可以访问构建后的页面 │ ├── build.js 生产环境构建脚本 │ ├── dev-client.js 开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新 │ ├── dev-server.js 运行本地开发服务器 │ ├── utils.js 构建相关工具方法 │ ├── webpack.base.conf.js wabpack基础配置 │ ├── webpack.dev.conf.js wabpack开发环境配置 │ └── webpack.prod.conf.js wabpack生产环境配置 ├── config 项目配置 │ ├── dev.env.js 开发环境变量 │ ├── index.js 项目配置文件 │ ├── prod.env.js 生产环境变量 │ └── test.env.js 测试环境变量 ├── mock mock数据目录 │ └── hello.js ├── package.json npm包配置文件，里面定义了项目的npm脚本，依赖包等信息 ├── src 源码目录 │ ├── main.js 入口js文件 │ ├── app.vue 根组件 │ ├── components 公共组件目录 │ │ └── title.vue │ ├── assets 资源目录，这里的资源会被wabpack构建 │ │ └── images │ │ └── logo.png │ ├── routes 前端路由 │ │ └── index.js │ ├── store 应用级数据（state）状态管理 │ │ └── index.js │ └── views 页面目录 │ ├── hello.vue │ └── notfound.vue ├── static 纯静态资源，不会被wabpack构建。 └── test 测试文件目录（unit&amp;e2e） └── unit 单元测试 ├── index.js 入口脚本 ├── karma.conf.js karma配置文件 └── specs 单测case目录 └── Hello.spec.js 4、安装element-ui接下来我们引入element-ui组件（https://element.eleme.cn） # 切换到项目根目录 cd vueblog-vue # 安装element-ui cnpm install element-ui --save 然后我们打开项目src目录下的main.js，引入element-ui依赖。 import Element from 'element-ui' import \"element-ui/lib/theme-chalk/index.css\" Vue.use(Element) 5、安装axios接下来，我们来安装axios（http://www.axios-js.com/），axios是一个基于 promise 的 HTTP 库，这样我们进行前后端对接的时候，使用这个工具可以提高我们的开发效率。 cnpm install axios --save 然后同样我们在main.js中全局引入axios。 import axios from 'axios' Vue.prototype.$axios = axios 组件中，我们就可以通过this.$axios.get()来发起我们的请求了哈。 6、页面路由接下来，我们先定义好路由和页面，因为我们只是做一个简单的博客项目，页面比较少，所以我们可以直接先定义好，然后在慢慢开发，这样需要用到链接的地方我们就可以直接可以使用： 我们在views文件夹下定义几个页面： BlogDetail.vue（博客详情页） BlogEdit.vue（编辑博客） Blogs.vue（博客列表） Login.vue（登录页面） 然后再路由中心配置： router\\index.js import Vue from 'vue' import VueRouter from 'vue-router' import Login from '../views/Login.vue' import BlogDetail from '../views/BlogDetail.vue' import BlogEdit from '../views/BlogEdit.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Index', redirect: { name: 'Blogs' } }, { path: '/login', name: 'Login', component: Login }, { path: '/blogs', name: 'Blogs', // 懒加载 component: () => import('../views/Blogs.vue') }, { path: '/blog/add', // 注意放在 path: '/blog/:blogId'之前 name: 'BlogAdd', meta: { requireAuth: true }, component: BlogEdit }, { path: '/blog/:blogId', name: 'BlogDetail', component: BlogDetail }, { path: '/blog/:blogId/edit', name: 'BlogEdit', meta: { requireAuth: true }, component: BlogEdit } ]; const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) export default router 接下来我们去开发我们的页面。其中，带有meta：requireAuth: true说明是需要登录字后才能访问的受限资源，后面我们路由权限拦截时候会用到。 7、登录页面 views/Login.vue 登录 重置 export default { name: \"Login\", data() { return { ruleForm: { username: 'markerhub', password: '111111' }, rules: { username: [ { required: true, message: '请输入用户名', trigger: 'blur' }, { min: 3, max: 15, message: '长度在 3 到 15 个字符', trigger: 'blur' } ], password: [ { required: true, message: '请输入密码', trigger: 'change' } ] } }; }, methods: { submitForm(userInfo) { this.$refs[userInfo].validate((valid) => { if (valid) { const _this = this this.$axios.post('/login', this.ruleForm).then(res => { console.log(res.data) const jwt = res.headers['authorization'] const userInfo = res.data.data // 把数据共享出去,通过commit提交函数 调用mutation中改变 store存储的变量 的函数 _this.$store.commit(\"SET_TOKEN\", jwt) _this.$store.commit(\"SET_USERINFO\", userInfo) // 获取 console.log(_this.$store.getters.getUser) _this.$router.push(\"/blogs\") //登录之后跳转到首页 }) } else { console.log('error submit!!'); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } .el-header, .el-footer .el-aside .el-main{ text-align: center; } .el-main { margin-top: 70px; } .mlogo { height: 100%; margin-top: 50px; margin-left: 40px; } .demo-ruleForm { max-width: 500px; margin: 0 auto; } 理解VueX作用 一个Vue项目可能会有很多页面和组件需要共享同一个变量，此时VueX中的store就像一个管家将需要共享的变量存储起来 通过类似于 get、set方法的回调函数进行变量获取和修改 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 每个 mutation (类似java中set方法的合集) 都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)**。它会接受 state 作为第一个参数 理解sessionStorage和localStorage sessionStorage 生命周期仅当前会话下有效，关闭页面或浏览器后被清除。 localStorage 生命周期是永久，这意味着除非用户手动清除，否则将永远存在。 两者都可以用 setItem、getItem、removeItem 来设置、获取、删除 token的状态同步所以在store/index.js中，代码是这样的： import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { token: '', //token 信息 userInfo: JSON.parse(sessionStorage.getItem(\"userInfo\")) }, mutations: { // 类似 java中的 set方法 SET_TOKEN: (state, token) => { state.token = token localStorage.setItem(\"token\", token) }, SET_USERINFO: (state, userInfo) => { state.userInfo = userInfo sessionStorage.setItem(\"userInfo\", JSON.stringify(userInfo)) }, REMOVE_INFO: (state) => { state.token = '' state.userInfo = {} localStorage.setItem(\"token\", '') sessionStorage.setItem(\"userInfo\", JSON.stringify('')) } }, getters: { // 类似 java中的 get方法 getUser: state => { return state.userInfo } }, actions: { }, modules: { } }) 存储token，我们用的是localStorage，存储用户信息，我们用的是sessionStorage。毕竟用户信息我们不需要长久保存，保存了token信息，我们随时都可以初始化用户信息。。 定义全局axios拦截器点击登录按钮发起登录请求，成功时候返回了数据，如果是密码错误，我们应该弹窗提示。对axios做个后置拦截器，返回数据的时候，如果结果的code或者status不正常，会有对应的弹窗提示。 在src目录下创建一个文件axios.js（与main.js同级），定义axios的拦截： import axios from 'axios' import Element from 'element-ui' import router from './router' import store from './store' axios.defaults.baseURL = \"http://localhost:8081\" //后端URL // 前置拦截 axios.interceptors.request.use(config => { return config }) axios.interceptors.response.use(response => { //返回的response的data中携带数据和状态码信息 let res = response.data; if (res.code === 200) { return response } else { Element.Message.error('密码错误', {duration: 3 * 1000}) //错误之后结束登录流程，返回错误信息 return Promise.reject(response.data.msg) } }, error => { //打印错误信息：例如用户名不存在 console.log(error) if(error.response.data) { error.message = error.response.data.msg } if(error.response.status === 401) { store.commit(\"REMOVE_INFO\") //错误之后，将数据清空，重新登录 router.push(\"/login\") } Element.Message.error(error.message, {duration: 3 * 1000}) return Promise.reject(error) } ) 然后再main.js中导入axios.js import './axios.js' // 请求拦截 后端因为返回的实体是Result，succ时候code为200，fail时候返回的是400，所以可以根据这里判断结果是否是正常的。另外权限不足时候可以通过请求结果的状态码来判断结果是否正常。这里都做了简单的处理。 8、博客列表登录完成之后直接进入博客列表页面，然后加载博客列表的数据渲染出来。同时页面头部我们需要把用户的信息展示出来，因为很多地方都用到这个模块，所以我们把页面头部的用户信息单独抽取出来作为一个组件。 头部用户信息那么，我们先来完成头部的用户信息，应该包含三部分信息：id，头像、用户名，而这些信息我们是在登录之后就已经存在了sessionStorage。因此，我们可以通过store的getters获取到用户信息。 看起来不是很复杂，我们贴出代码： components\\Header.vue 欢迎来到MarkerHub的博客 {{ user.username }} 主页 发表文章 登陆 退出 export default { name: \"Header\", data() { return { hasLogin: false, user: { username: '请先登录', avatar: \"https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png\" }, blogs: {}, currentPage: 1, total: 0 } }, methods: { logout() { const _this = this this.$axios.get('http://localhost:8081/logout', { headers: { \"Authorization\": localStorage.getItem(\"token\") } }).then((res) => { _this.$store.commit('REMOVE_INFO') _this.$router.push('/login') }); } }, created() { if(this.$store.getters.getUser.username) { this.user.username = this.$store.getters.getUser.username this.user.avatar = this.$store.getters.getUser.avatar this.hasLogin = true } } } 上面代码created()中初始化用户的信息，通过hasLogin的状态来控制登录和退出按钮的切换，以及发表文章链接的disabled，这样用户的信息就能展示出来了。然后这里有个退出按钮，在methods中有个logout()方法，逻辑比较简单，直接访问/logout，因为之前axios.js中我们已经设置axios请求的baseURL，所以这里我们不再需要链接的前缀了哈。因为是登录之后才能访问的受限资源，所以在header中带上了Authorization。返回结果清楚store中的用户信息和token信息，跳转到登录页面。 然后需要头部用户信息的页面只需要几个步骤： import Header from \"@/components/Header\"; data() { components: {Header} } # 然后模板中调用组件 博客分页接下来就是列表页面，需要做分页，列表我们在element-ui中直接使用时间线组件来作为我们的列表样式，还是挺好看的。还有我们的分页组件。 需要几部分信息： 分页信息 博客列表内容，包括id、标题、摘要、创建时间 views\\Blogs.vue {{blog.title}} {{blog.description}} import Header from \"@/components/Header\"; export default { name: \"Blogs\", components: {Header}, data() { return { blogs: {}, currentPage: 1, total: 0, pageSize: 5 } }, methods: { page(currentPage) { const _this = this this.$axios.get('http://localhost:8081/blogs?currentPage=' + currentPage).then((res) => { console.log(res.data.data.records) _this.blogs = res.data.data.records _this.currentPage = res.data.data.current _this.total = res.data.data.total _this.pageSize = res.data.data.size }) } }, mounted () { this.page(1); } } data()中直接定义博客列表blogs、以及一些分页信息。methods()中定义分页的调用接口page（currentPage），参数是需要调整的页码currentPage，得到结果之后直接赋值即可。然后初始化时候，直接在mounted()方法中调用第一页this.page(1)。完美。使用element-ui组件就是简单快捷哈哈！注意标题这里我们添加了链接，使用的是标签。 9、博客编辑（发表）我们点击发表博客链接调整到/blog/add页面，这里我们需要用到一个markdown编辑器，在vue组件中，比较好用的是mavon-editor，那么我们直接使用哈。先来安装mavon-editor相关组件： 安装mavon-editor基于Vue的markdown编辑器mavon-editor cnpm install mavon-editor --save 然后在main.js中全局注册： // 全局注册 import Vue from 'vue' import mavonEditor from 'mavon-editor' import 'mavon-editor/dist/css/index.css' // use Vue.use(mavonEditor) ok，那么我们去定义我们的博客表单： 立即创建 取消 import Header from \"@/components/Header\"; export default { name: \"BlogEdit\", components: {Header}, data() { return { editForm: { id: null, title: '', description: '', content: '' }, rules: { title: [ {required: true, message: '请输入标题', trigger: 'blur'}, {min: 3, max: 50, message: '长度在 3 到 50 个字符', trigger: 'blur'} ], description: [ {required: true, message: '请输入摘要', trigger: 'blur'} ] } } }, created() { const blogId = this.$route.params.blogId const _this = this if(blogId) { this.$axios.get('/blog/' + blogId).then((res) => { const blog = res.data.data _this.editForm.id = blog.id _this.editForm.title = blog.title _this.editForm.description = blog.description _this.editForm.content = blog.content }); } }, methods: { submitForm() { const _this = this this.$refs.editForm.validate((valid) => { if (valid) { this.$axios.post('/blog/edit', this.editForm, { headers: { \"Authorization\": localStorage.getItem(\"token\") } }).then((res) => { _this.$alert('操作成功', '提示', { confirmButtonText: '确定', callback: action => { _this.$router.push(\"/blogs\") } }); }); } else { console.log('error submit!!'); return false; } }) } } } 逻辑依然简单，校验表单，然后点击按钮提交表单，注意头部加上Authorization信息，返回结果弹窗提示操作成功，然后跳转到博客列表页面。emm，和写ajax没啥区别。熟悉一下vue的一些指令使用即可。然后因为编辑和添加是同一个页面，所以有了create()方法，比如从编辑连接/blog/7/edit中获取blogId为7的这个id。然后回显博客信息。获取方式是const blogId = this.$route.params.blogId。 对了，mavon-editor因为已经全局注册，所以我们直接使用组件即可： 效果如下： 10、博客详情博客详情中需要回显博客信息，然后有个问题就是，后端传过来的是博客内容是markdown格式的内容，我们需要进行渲染然后显示出来，这里我们使用一个插件markdown-it，用于解析md文档，然后导入github-markdown-c，所谓md的样式。 方法如下： # 用于解析md文档 cnpm install markdown-it --save # md样式 cnpm install github-markdown-css 然后就可以在需要渲染的地方使用： views\\BlogDetail.vue {{ blog.title }} 编辑 import 'github-markdown-css/github-markdown.css' // 然后添加样式markdown-body import Header from \"@/components/Header\"; export default { name: \"BlogDetail\", components: { Header }, data() { return { blog: { userId: null, title: \"\", description: \"\", content: \"\" }, ownBlog: false } }, methods: { getBlog() { const blogId = this.$route.params.blogId const _this = this this.$axios.get('/blog/' + blogId).then((res) => { console.log(res) console.log(res.data.data) _this.blog = res.data.data var MarkdownIt = require('markdown-it'), md = new MarkdownIt(); var result = md.render(_this.blog.content); _this.blog.content = result // 判断是否是自己的文章，能否编辑 _this.ownBlog = (_this.blog.userId === _this.$store.getters.getUser.id) }); } }, created() { this.getBlog() } } 具体逻辑还是挺简单，初始化create()方法中调用getBlog()方法，请求博客详情接口，返回的博客详情content通过markdown-it工具进行渲染。 再导入样式： import 'github-markdown.css' 然后在content的div中添加class为markdown-body即可哈。 另外标题下添加了个小小的编辑按钮，通过ownBlog （判断博文作者与登录用户是否同一人）来判断按钮是否显示出来。 11、路由权限拦截页面已经开发完毕之后，我们来控制一下哪些页面是需要登录之后才能跳转的，如果未登录访问就直接重定向到登录页面，因此我们在src目录下定义一个js文件： src\\permission.js import router from \"./router\"; // 路由判断登录 根据路由配置文件的参数 router.beforeEach((to, from, next) => { if (to.matched.some(record => record.meta.requireAuth)) { // 判断该路由是否需要登录权限 const token = localStorage.getItem(\"token\") console.log(\"------------\" + token) if (token) { // 判断当前的token是否存在 ； 登录存入的token if (to.path === '/login') { } else { next() } } else { next({ path: '/login' }) } } else { next() } }) 通过之前我们再定义页面路由时候的的meta信息，指定requireAuth: true，需要登录才能访问，因此这里我们在每次路由之前（router.beforeEach）判断token的状态，觉得是否需要跳转到登录页面。 { path: '/blog/add', // 注意放在 path: '/blog/:blogId'之前 name: 'BlogAdd', meta: { requireAuth: true }, component: BlogEdit } 然后我们再main.js中import我们的permission.js import './permission.js' // 路由拦截","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"前后端分离项目——后台管理系统","date":"2022-03-18T08:53:48.365Z","updated":"2022-03-18T09:26:19.563Z","comments":true,"path":"2022/03/18/qian-hou-duan-fen-chi-xiang-mu-hou-tai-guan-li-xi-tong/","link":"","permalink":"https://lycode1202.github.io/2022/03/18/qian-hou-duan-fen-chi-xiang-mu-hou-tai-guan-li-xi-tong/","excerpt":"","text":"管理系统开发搭建后端程序1、Spring Initializr 创建后端项目 2、后期引入需要的依赖 &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jdbc&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!--spring整合mybatis-plus --> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;/dependency> &lt;!--Mybatis代码生成器--> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-generator&lt;/artifactId> &lt;version>3.5.1&lt;/version> &lt;/dependency> &lt;!--velocity 模板引擎，Mybatis Plus 代码生成器需要（默认模板引擎）--> &lt;dependency> &lt;groupId>org.apache.velocity&lt;/groupId> &lt;artifactId>velocity&lt;/artifactId> &lt;version>1.7&lt;/version> &lt;/dependency> &lt;!--hutool--> &lt;dependency> &lt;groupId>cn.hutool&lt;/groupId> &lt;artifactId>hutool-all&lt;/artifactId> &lt;version>5.7.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi-ooxml&lt;/artifactId> &lt;version>4.1.2&lt;/version> &lt;/dependency> &lt;/dependencies> 3、对全局配置文件application.yaml进行修改 server: port: 8080 servlet: context-path: / tomcat: uri-encoding: utf-8 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/database?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC username: root password: root # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 ## 集群版本 redis: database: 0 pool: max-active: 100 #连接池最大连接数（负值表示没有限制） max-wait: 3000 #连接池最大阻塞等待时间（负值表示没有限制） max-idle: 200 #连接池最大空闭连接数 min-idle: 50 #连接汉最小空闲连接数 timeout: 600 #连接超时时间（毫秒） cluster: nodes: - 192.168.75.132:6380 - 192.168.75.132:6381 - 192.168.75.132:6382 - 192.168.75.132:6383 - 192.168.75.132:6384 - 192.168.75.132:6385 ## 单机版本 redis: host: 192.168.75.132 port: 6379 jpa: show-sql: true properties: hibernate: format_sql: true mybatis: mapper-locations: classpath:mapping/*.xml type-aliases-package: cn.felixfang.flog.entity #mybatis-plus配置 mybatis-plus: mapper-locations: classpath:/mybatis/mappers/*.xml #配置Mapper映射文件 type-aliases-package: com.yunnuo.server.pojo # 配置Mybatis数据返回类型别名（默认别名为类名） configuration: map-underscore-to-camel-case: false # 自动驼峰命名 #配置控制台打印日志Debug logging: level: com.jd.mapper: debug #自己也可以配置属性，通过@value、@ConfigurationProperties(prefix=\"\")、@Component注入属性 my: users: - name: 大李 age: 100 - name: 小刘 age: 200 4、利用代码生成器codeGenerator package com.ly.utils; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import java.util.Collections; /** * mp代码生成器 */ public class codeGenerator { public static void main(String[] args) { generate(); } private static void generate(){ FastAutoGenerator.create(\"jdbc:mysql://localhost:3306/project?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true&amp;serverTimezone=GMT%2B8&amp;useSSL=false\", \"root\", \"123456\") .globalConfig(builder -> { builder.author(\"ly\") // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(\"E:\\\\code_set\\\\IdeaProjects\\\\ly_aftermanage\\\\src\\\\main\\\\java\\\\\"); // 指定输出目录 }) .packageConfig(builder -> { builder.parent(\"com.ly\") // 设置父包名 .moduleName(null) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, \"E:\\\\code_set\\\\IdeaProjects\\\\ly_aftermanage\\\\src\\\\main\\\\resources\\\\Mapper\\\\\")); // 设置mapperXml生成路径 }) .strategyConfig(builder -> { builder.entityBuilder().enableLombok(); builder.mapperBuilder().enableMapperAnnotation().build(); builder.controllerBuilder().enableHyphenStyle() // 开启驼峰转连字符 .enableRestStyle(); // 开启生成@RestController 控制器 builder.addInclude(\"menu\") // 设置需要生成的表名 .addTablePrefix(\"t_\", \"c_\"); // 设置过滤表前缀 }) // .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); } } 5、修改代码生成器模板 maven仓库内搜索mybatis-plus-generator,打开，复制其中的templates目录至自己项目的resources下 所有的vm都是默认模板，也可以使用别的模板引擎来生成代码 package ${package.Controller}; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; import ${package.Service}.${table.serviceName}; import ${package.Entity}.${entity}; #if(${restControllerStyle}) import org.springframework.web.bind.annotation.RestController; #else import org.springframework.stereotype.Controller; #end #if(${superControllerClassPackage}) import ${superControllerClassPackage}; #end /** * @author ${author} * @since ${date} */ #if(${restControllerStyle}) @RestController #else @Controller #end @RequestMapping(\"#if(${package.ModuleName})/${package.ModuleName}#end/#if(${controllerMappingHyphenStyle})${controllerMappingHyphen}#else${table.entityPath}#end\") #if(${kotlin}) class ${table.controllerName}#if(${superControllerClass}) : ${superControllerClass}()#end #else #if(${superControllerClass}) public class ${table.controllerName} extends ${superControllerClass} { #else public class ${table.controllerName} { #end @Resource private ${table.serviceName} ${table.entityPath}Service; //新增或者更新 @PostMapping public result save(@RequestBody ${entity} ${table.entityPath}) { return result.success(${table.entityPath}Service.saveOrUpdate(${table.entityPath})); } //删除 @DeleteMapping(\"/{id}\") public result delete(@PathVariable Integer id) { return result.success(${table.entityPath}Service.removeById(id)); } //批量删除 @PostMapping(\"/del/batch\") //地址记得变更 public result deleteBatch(@RequestBody List&lt;Integer> ids){ return result.success(${table.entityPath}Service.removeBatchByIds(ids)); } //查询所有 @GetMapping public result findAll() { return result.success(${table.entityPath}Service.list()); } //根据id查询 @GetMapping(\"/{id}\") public result findOne(@PathVariable Integer id) { return result.success(${table.entityPath}Service.getById(id)); } //分页查询 @GetMapping(\"/page\") public result findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) { QueryWrapper&lt;${entity}> queryWrapper = new QueryWrapper&lt;>(); queryWrapper.orderByDesc(\"id\"); return result.success(${table.entityPath}Service.page(new Page&lt;>(pageNum, pageSize),queryWrapper)); } } #end 6、搭建数据库database，制作所需要的用户表、系统表、权限表、文件表等等 7、通过codegenerator生成对应表的对应实体类、mapper、controller、service等 8、编写Controller层和Service层业务逻辑代码 9、通过Constants类封装状态码，结合Result返回类封装返回参数 public class Constants { public static String CODE_200 = \"200\"; //成功 public static String CODE_500 = \"500\"; //系统错误 public static String CODE_401 = \"401\"; //权限不足 public static String CODE_400 = \"400\"; //参数错误 public static String CODE_600 = \"600\"; //数据错误 } package com.ly.common; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * 接口统一返回包装类 */ @Data @NoArgsConstructor @AllArgsConstructor public class result { private String code; private String msg; private Object data; public static result success(){ return new result(Constants.CODE_200,\"\",null); } public static result success(Object data){ return new result(Constants.CODE_200,\"\",data); } public static result error(String code,String msg){ return new result(code,msg,null); } public static result error(){ return new result(Constants.CODE_500,\"系统错误\",null); } } 常见问题跨域问题 配置跨域访问的配置类CorsConfig package com.ly.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class CorsConfig { // 当前跨域请求最大有效时长。这里默认1天 private static final long MAX_AGE = 24 * 60 * 60; @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\"*\"); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(\"*\"); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(\"*\"); // 3 设置访问源请求方法 corsConfiguration.setMaxAge(MAX_AGE); source.registerCorsConfiguration(\"/**\", corsConfiguration); // 4 对接口配置跨域设置 return new CorsFilter(source); } } 登录校验问题 使用jwt利用token进行登录校验 package com.ly.config.interceptor; import cn.hutool.core.util.StrUtil; import com.auth0.jwt.JWT; import com.auth0.jwt.JWTVerifier; import com.auth0.jwt.algorithms.Algorithm; import com.auth0.jwt.exceptions.JWTDecodeException; import com.auth0.jwt.exceptions.JWTVerificationException; import com.ly.common.Constants; import com.ly.entity.User; import com.ly.exception.ServiceException; import com.ly.service.IUserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class JwtInterceptor implements HandlerInterceptor { @Autowired private IUserService userService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getHeader(\"token\"); //如果不是映射的方法直接通过 if (!(handler instanceof HandlerMethod)){ return true; } //执行认证 if (StrUtil.isBlank(token)){ throw new ServiceException(Constants.CODE_401,\"无token，请重新登录\"); } //获取token中的userid String userId; try { userId = JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException e) { throw new ServiceException(Constants.CODE_401,\"token验证失败\"); } //根据token中的userid查询数据库 User user = userService.getById(userId); if (user == null){ throw new ServiceException(Constants.CODE_401,\"用户不存在，请重新登录\"); } //用户密码加签验证token JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build(); try { jwtVerifier.verify(token); } catch (JWTVerificationException e) { throw new ServiceException(Constants.CODE_401,\"token验证失败，请重新登录\"); } return true; } } 开发需求权限菜单分配利用redis缓存","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"网络安全","date":"2022-03-14T16:18:37.895Z","updated":"2022-03-15T07:41:41.181Z","comments":true,"path":"2022/03/15/wang-luo-an-quan/","link":"","permalink":"https://lycode1202.github.io/2022/03/15/wang-luo-an-quan/","excerpt":"","text":"渗透准备知识网络安全安全常见漏洞 不完善的身份验证措施 不完善的访问控制措施 SQL注入 跨站点脚本 信息泄露 跨站点请求伪造 网络攻击图 WEB应用技术HTTP 客户端通过浏览器 —— 获取——服务端数据信息 客户端通过浏览器——提交——服务端后台程序（数据库服务器 缓存服务器 存储服务） HTTP请求报文请求报文信息 请求行 请求头 空行 请求主体 响应报文信息 响应行 响应头 空行 响应主体（获取数据信息 文本 图片 视频 音频 代码信息） HTTP请求字段名称及作用请求报文信息： Accept ：识别网站资源 Referer ：外部链接（访问此网站前是从其他网站跳转过来的，会做一个记录；可以防止盗链，别人盗取网站资源） Accept-Language : 支持的语言 User-Agent ：客户端访问服务端软件信息（例如：Windows上的Chrome浏览器访问；也可显示移动端访问：iPhone、Android） Accept-Encoding ：资源压缩请求，利于访问减少带宽占用 Host ：域名，确定网站访问信息 Connecting ：Keep-Alive 一般都是长连接 none 短链接 ： 一次链接（tcp三次握手）一次请求，请求完断开 长连接 ： 一次链接（tcp三次握手） 在时间域内多次请求 响应报文信息： HTTP/1.1 200 OK ：状态码和协议 Date ：时期 Server ：浏览器 X-Power-By ：框架 Cache-Control ：缓存控制 Content-Type ：响应主体信息类型 Content-Length ：数据字节大小 请求方法： 请求方法 get ： 从服务器获取资源数据信息 （不会有请求主体） post ：向服务器提交资源数据信息 （字符信息提交） put ：向服务端提交文档附件资源 head ：类似get，不返回消息主体 trace ：用于诊断 options ：要求服务器报告对某一特殊资源有效的HTTP方法 用法：黑客利用 HTTP请求包（携带OPTIONS）–&gt; www.xx.com –&gt; 查看是否有安全控制 ，若没有服务器端 –&gt; 返回HTTP响应报文中携带支持访问的方法信息：如GET POST PUT MOVE HEAD ，这些方法会被黑客利用植入木马等病毒程序 put ：上传信息 URL统一资源定位符格式： protocol://hostname[:port]/[path/Ifile[?Param=valuel protocol : http https ftp hostname : IP地址 、域名信息 port : 端口号，例[8002] nginx、apache、tomcat path/Ifile ：资源路径（访问静态资源的时候） Param ：参数（动态资源：index.php) HTTP消息头 Authorization ：为一种内置HTTP身份验证向服务器提交证书 Location ：用于重定向响应（那些状态码以3开头的响应）中说明重定向的目标 www.360buy.com –&gt; www.jd.com 状态码 1xx ：提供信息 100 客户必须继续发出请求 101 客户要求服务器根据请求转换HTTP协议版本 2xx ：请求被成功提交 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 3xx ：客户端被重定向到其他资源 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx ：请求包含某种错误 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 5xx ：服务器执行请求时遇到错误 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 Cookie用户访问网站的身份证，用来存储一些用户信息，用于辨别用户身份 Cookie类型 会话Cookie 用户推出浏览器访问后，即删除 持久Cookie 存储到硬盘中，维护用户周期性访问网站 Cookie域 Domain属性 访问不同的网站会有很多个不同的Cookie，如何辨识Cookie对应哪个网站，我们在Cookie中引入Domain属性 Path属性 一个网站中有无数不同的资源和页面，访问同一个网站的不同页面时也会产生不同的Cookie，所以通过path属性来标识特定文档资源 第三方Cookie用来根据用户喜好进行内容推广使用，由于经常使用浏览器访问不同的网站和产品、广告，每次访问时会产生对应的第三方Cookie，等你再次访问其他网站时，它会自动读取，并且给你推荐相关产品 网站渗透技术漏洞扫描1、链路检测扫描 利用ping命令进行测试扫描检查网络连通性 ping命令进行扫描时，会先检查网络的连通性，然后根据测试扫描后的TTL值的输出，判断所扫描的系统类型（windows、linux、交换机） 2、端口检测扫描 利用telnet命令进行测试扫描检查网络端口 telnet命令扫描会进行检查网络的端口是否开放，根据访问输出消息即可进行判断 3、OS检测扫描 OS扫描是黑客进行OS漏洞攻击的前奏,实时检测OS扫描是防止系统遭受OS漏洞攻击的重要手段。 利用nmap命令测试扫描检查网络系统信息，使用TCP/IP协议栈指纹来识别不同的操作系统和设备。 具体实现方式如下： nmap内部包含了2600多已知系统的指纹特征（在文件nmap-os-db文件中记录）。将此指纹数据库作为进行指纹对比的样本库。 分别挑选一个open和closed的端口，向其发送经过精心设计的TCP/UDP/ICMP数据包，根据返回的数据包生成一份系统指纹。 将探测生成的指纹与namp-os-db中指纹进行对比，查找匹配的系统。如果无法匹配，以概率形式列举出可能的系统。 4、弱口令探测 尝试安全性差的密码信息，一般的都是采用穷举破解原理 ,或者是利用字典文件加快破解速度 ,对常见的弱口令的收集 5、漏洞评估检测 利用漏洞扫描器，针对网络、应用、数据库的已知的漏洞评估，识别和量化环境中的安全漏洞。 扫描技术 扫描工具 X-Scan —— 对指定主机或IP地址段进行安全检测 设置 → 扫描参数 → 检测范围（输入IP地址） → 全局设置 （按照自己的需求设置）→ 查看扫描报告 AppScan —— 一个桌面应用程序，进行web应用程序自动化脆弱性评估。先破解 → 文件 → 新建扫描 → 常规扫描 → AppScan（自动或手动）→ 输入网站IP地址的URL → 扫描网站生成报告 AWVS —— 自动化web测试工具 先激活再使用 Web渗透攻防环境搭建部署虚拟主机 Windows 2003/2008 Windows 7/10 Linux kail/centos 网站服务架构平台推荐： Windows 下的LNMP 、LAMP 、LNMT ，利用软件（phpstudy）","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"小程序项目开发","date":"2022-03-10T04:56:02.400Z","updated":"2022-03-10T04:56:02.401Z","comments":true,"path":"2022/03/10/xiao-cheng-xu-xiang-mu-kai-fa/","link":"","permalink":"https://lycode1202.github.io/2022/03/10/xiao-cheng-xu-xiang-mu-kai-fa/","excerpt":"","text":"小程序项目开发FinCilp 小程序开发框架","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Git分布式版本控制工具","slug":"Git分布式版本控制工具","date":"2022-03-05T16:00:00.000Z","updated":"2022-03-10T03:48:49.967Z","comments":true,"path":"2022/03/06/git-fen-bu-shi-ban-ben-kong-zhi-gong-ju/","link":"","permalink":"https://lycode1202.github.io/2022/03/06/git-fen-bu-shi-ban-ben-kong-zhi-gong-ju/","excerpt":"","text":"Git分布式版本控制工具1 、目标 了解Git基本概念 能够概述git工作流程 能够使用Git常用命令 熟悉Git代码托管服务 能够使用idea操作git 2 、概述2.1、开发中的实际场景场景一：备份 小明负责的模块就要完成了，就在即将Release之前的一瞬间，电脑突然蓝屏，硬盘光荣牺牲！几个月来的努力付之东流 场景二：代码还原 这个项目中需要一个很复杂的功能，老王摸索了一个星期终于有眉目了，可是这被改得面目全非的代码已经回不到从前了。什么地方能买到哆啦A梦的时光机啊？ 场景三：协同开发 小刚和小强先后从文件服务器上下载了同一个文件：Analysis.java。小刚在Analysis.java文件中的第 30 行声明了一个方法，叫count()，先保存到了文件服务器上；小强在Analysis.java文件中的第 50 行声明了一个方法，叫sum()，也随后保存到了文件服务器上，于是，count()方法就只存在于小刚的记忆中了 场景四：追溯问题代码的编写人和编写时间！ 老王是另一位项目经理，每次因为项目进度挨骂之后，他都不知道该扣哪个程序员的工资！就拿这次来说吧，有个Bug调试了 30 多个小时才知道是因为相关属性没有在应用初始化时赋值！可是二胖、王东、刘流和正经牛都不承认是自己干的！ 2.2、版本控制器的方式a、集中式版本控制工具 集中式版本控制工具，版本库是集中存放在中央服务器的，team里每个人work时从中央服务器下载代码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。 举例：SVN和CVS b、分布式版本控制工具 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。 举例：Git 2.3、SVN 2.4、Git Git是分布式的,Git不需要有中心服务器，我们每台电脑拥有的东西都是一样的。我们使用Git并且有个中心服务器，仅仅是为了方便交换大家的修改，但是这个服务器的地位和我们每个人的PC是一样的。我们可以把它当做一个开发者的pc就可以就是为了大家代码容易交流不关机用的。没有它大家一样可以工作，只不过“交换”修改不方便而已。 git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（ 1991 － 2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 2.5、Git工作流程图 命令如下： 1. clone（克隆）: 从远程仓库中克隆代码到本地仓库 2. checkout（检出）:从本地仓库中检出一个仓库分支然后进行修订 3. add（添加）: 在提交前先将代码提交到暂存区 4. commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本 5. fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。 6. pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge 7. push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 3 、Git安装与常用命令本教程里的git命令例子都是在Git Bash中演示的，会用到一些基本的linux命令，在此为大家提前列举： ls/ll 查看当前目录 cat 查看文件内容 touch 创建文件 vi/vi编辑器 （使用vi编辑器是为了方便展示效果，学员可以记事本、editPlus、notPad++等其它编辑器） 3.1、 Git环境配置3.1.1 下载与安装 下载地址： https://git-scm.com/download 双击下载的安装文件来安装Git。安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。 备注： Git GUI：Git提供的图形界面工具 Git Bash：Git提供的命令行工具 当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息 3.1.2基本配置 打开Git Bash 设置用户信息 查看配置信息 git config --global user.name “itcast” git config --global user.email “hello@itcast.cn” git config --list 3.1.3 为常用指令配置别名（可选） 有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。 打开用户目录，创建.bashrc文件 部分windows系统不允许用户创建点号开头的文件，可以打开gitBash,执行 touch ~/.bashrc 在.bashrc文件中输入如下内容： #用于输出git提交日志 alias git-log='git log --pretty=oneline --all --graph --abbrev-commit' #用于输出当前目录所有文件及基本信息 alias ll='ls -al' 打开gitBash，执行source ~/.bashrc 3.1.4 解决GitBash乱码问题 打开GitBash执行下面命令 git config --global core.quotepath false ${git_home}/etc/bash.bashrc 文件最后加入下面两行 export LANG=\"zh_CN.UTF-8\" export LC_ALL=\"zh_CN.UTF-8\" 3.2、获取本地仓库要使用Git对我们的代码进行版本控制，首先需要获得本地仓库 1 ）在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库 2 ）进入这个目录中，点击右键打开Git bash窗口 3 ）执行命令git init 4 ）如果创建成功后可在文件夹下看到隐藏的.git目录。 3.3、基础操作指令Git工作目录下对于文件的 修改 (增加、删除、更新)会存在几个状态，这些 修改 的状态会随着我们执行Git的命令而发生变化。 本章节主要讲解如何使用命令来控制这些状态之间的转换： git add (工作区 –&gt; 暂存区) git commit (暂存区 –&gt; 本地仓库) 3.3.1、*查看修改的状态（status） 作用：查看的修改的状态（暂存区、工作区） 命令形式：git status 3.3.2、*添加工作区到暂存区(add) 作用：添加工作区一个或多个文件的修改到暂存区 命令形式：git add 单个文件名|通配符 将所有修改加入暂存区： git add . 3.3.3、*提交暂存区到本地仓库(commit) 作用：提交暂存区内容到本地仓库的当前分支 命令形式：git commit -m ‘注释内容’ 3.3.4、*查看提交日志(log) git-log 在3.1.3中配置的别名 git - log 就包含了这些参数，所以后续可以直接使用指令 git-log 作用:查看提交记录 命令形式：git log [option] options –all 显示所有分支 –pretty=oneline 将提交信息显示为一行 –abbrev-commit 使得输出的commitId更简短 –graph 以图的形式显示 3.3.5、版本回退 作用：版本切换 命令形式：git reset –hard commitID commitID 可以使用git-log或git log指令查看 如何查看已经删除的记录？ git reflog 这个指令可以看到已经删除的提交记录 3.3.6、添加文件至忽略列表 一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例： 练习:基础操作 # no .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf #####################仓库初始化###################### # 创建目录（git_test01）并在目录下打开gitbash 略 # 初始化git仓库 git init #####################创建文件并提交##################### # 目录下创建文件 file01.txt 略 # 将修改加入暂存区 git add . # 将修改提交到本地仓库，提交记录内容为：commit 001 git commit -m 'commit 001' # 查看日志 git log ####################修改文件并提交###################### # 修改file01的内容为：count= 略 # 将修改加入暂存区 git add. # # 将修改提交到本地仓库，提交记录内容为：update file git commit --m 'update file01' # 查看日志 git log # 以精简的方式显示提交记录 git-log ####################将最后一次修改还原################## # 查看提交记录 git-log # 找到倒数第 2 次提交的commitID 略 # 版本回退,想要回退哪一步，就找到该步的commitID git reset commitID --hard 3.4、分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。 3.4.1、查看本地分支 命令：git branch 3.4.2、创建本地分支 命令：git branch 分支名 3.4.4、*切换分支(checkout) 命令：git checkout 分支名 我们还可以直接切换到一个不存在的分支（创建并切换） 命令：git checkout -b 分支名 3.4.6、*合并分支(merge) 一个分支上的提交可以合并到另一个分支，首先切换到想要合并的分支上，然后选中被合并的分支 命令：git merge 分支名称 3.4.7、删除分支 不能删除当前分支，只能删除其他分支 git branch -d b1 删除分支时，需要做各种检查 git branch -D b1 不做任何检查，强制删除 3.4.8、解决冲突 当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下： 1. 处理文件中冲突的地方 2. 将解决完冲突的文件加入暂存区(add) 3. 提交到仓库(commit) 冲突部分的内容处理如下所示： 1、准备新的feature1分支，继续我们的新分支开发： $ git switch -c feature1 Switched to a new branch 'feature1' 2、修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 3、在feature1分支上提交： $ git add readme.txt $ git commit -m \"AND simple\" [feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 4、切换到master分支： $ git switch master Switched to branch 'master' Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 5、在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick &amp; simple. 提交： $ git add readme.txt $ git commit -m \"&amp; simple\" [master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 6、这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 7、果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add &lt;file>...\" to mark resolution) both modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 8、我们可以直接查看readme.txt的内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. >>>>>>> feature1 9、Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 10、再提交： $ git add readme.txt $ git commit -m \"conflict fixed\" [master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： 11、用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -> master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt * b84166e add test.txt * 519219b git tracks changes * e43a48b understand how stage works * 1094adb append GPL * e475afc add distributed * eaadf4e wrote a readme file 12、最后，删除feature1分支： $ git branch -d feature1 Deleted branch feature1 (was 14096d0). 3.4.9、开发中分支使用原则与流程 几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。 在开发中，一般有如下分支使用原则与流程： master （生产） 分支 线上分支，主分支，中小规模项目作为线上运行的应用对应的分支； develop（开发）分支 是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。 feature/xxxx分支 从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。 hotfix/xxxx分支， 从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。 还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等 等。 练习:分支操作 4 、Git远程仓库4.1、 常用的托管服务[远程仓库]###########################创建并切换到dev01分支，在dev01分支提交 # [master]创建分支dev git branch dev # [master]切换到dev git checkout dev # [dev01]创建文件file02.txt 略 # [dev01]将修改加入暂存区并提交到仓库,提交记录内容为：add file02 on dev git add. git commit -m 'add file02 on dev' # [dev01]以精简的方式显示提交记录 git-log ###########################切换到master分支，将dev01合并到master分支 # [dev01]切换到master分支 git checkout master # [master]合并dev01到master分支 git merge dev # [master]以精简的方式显示提交记录 git-log # [master]查看文件变化(目录下也出现了file02.txt) 略 ##########################删除dev01分支 # [master]删除dev01分支 git branch -d dev # [master]以精简的方式显示提交记录 git-log 4.2、 注册码云要想使用码云的相关服务，需要注册账号（地址： https://gitee.com/signup ） 4.3、 创建远程仓库前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库 呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。 gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub 码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快 GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。 仓库创建完成后可以看到仓库地址，如下图所示: 4.4、配置SSH公钥生成SSH公钥 ssh-keygen -t rsa 不断回车 如果公钥已经存在，则自动覆盖 Gitee设置账户共公钥 获取公钥 cat ~/.ssh/id_rsa.pub 验证是否配置成功 ssh -T git@gitee.com 4.5、操作远程仓库4.5.1、添加远程仓库 此操作是先初始化本地库，然后与已创建的远程库进行对接 。 命令： git remote add &lt;远端名称> &lt;仓库路径> 远端名称，默认是origin，取决于远端服务器设置 仓库路径，从远端服务器获取此URL 例如: git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git 4.5.2、查看远程仓库 命令：git remote 4.5.3、推送到远程仓库 命令：git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ] 如果远程分支名和本地分支名称相同，则可以只写本地分支 git push origin master -f 表示强制覆盖 --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。 git push --set-upstream origin master 如果 当前分支已经和远端分支关联 ，则可以省略分支名和远端名。 git push 将master分支推送到已关联的远端分支。 查询远程仓库 4.5.4、 本地分支与远程分支的关联关系 查看关联关系我们可以使用 git branch -vv命令 4.5.5、从远程仓库克隆 如果已经有一个远端仓库，我们可以直接clone到本地。 命令: git clone &lt;仓库路径> [本地目录] 本地目录可以省略，会自动生成一个目录 4.5.6、从远程仓库中抓取和拉取 远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。 抓取 命令：git fetch [remote name] [branch name] 抓取指令就是将仓库里的更新都抓取到本地，不会进行合并 如果不指定远端名称和分支名，则抓取所有分支。 拉取 命令：git pull [remote name] [branch name] 拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 如果不指定远端名称和分支名，则抓取所有并更新当前分支。 1. 在test01这个本地仓库进行一次提交并推送到远程仓库 在另一个仓库将远程提交的代码拉取到本地仓库 4.5.7、解决合并冲突 在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户， 故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支 ,如下图所示。 在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。 远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同 ，在此不再赘述，需要学员自己练习。 练习:远程仓库操作 5 、在Idea中使用Git5.1、在Idea中配置Git##########################1-将本地仓库推送到远程仓库 # 完成4.1、4.2、4.3、4.4的操作 略 # [git_test01]添加远程仓库 git remote add origin git@gitee.com/**/**.git # [git_test01]将master分支推送到远程仓库,并与远程仓库的master分支绑定关联关系 git push --set-upstream origin master ###########################2-将远程仓库克隆到本地 # 将远程仓库克隆到本地git_test02目录下 git clone git@gitee.com/**/**.git git_test # [git_test02]以精简的方式显示提交记录 git-log ###########################3-将本地修改推送到远程仓库 # [git_test01]创建文件file03.txt 略 # [git_test01]将修改加入暂存区并提交到仓库,提交记录内容为：add file git add. git commit -m 'add file03' # [git_test01]将master分支的修改推送到远程仓库 git push origin master ###########################4-将远程仓库的修改更新到本地 # [git_test02]将远程仓库修改再拉取到本地 git pull # 以精简的方式显示提交记录 git-log # 查看文件变化(目录下也出现了file03.txt) 略 安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。选择File→Settings打开设置窗口，找到Version Control下的git选项： 点击Test按钮,现在执行成功，配置完成 5.2、在Idea中操作Git场景：本地已经有一个项目，但是并不是git项目，我们需要将这个放到码云的仓库里，和其他开发人员继续一起协作开发。 5.2.1、创建项目远程仓库（参照4.3） 5.2.2、初始化本地仓库 5.2.3、设置远程仓库 5.2.4、提交到本地仓库 5.2.6、推送到远程仓库 5.2.7、克隆远程仓库到本地 5.2.8、创建分支 最常规的方式 最强大的的方式 5.2.9、切换分支及其他分支相关操作 5.2.11、解决冲突 执行merge或pull操作时，可能发生冲突 冲突解决后加入暂存区 提交到本地仓库 推送到远程仓库 5.3、IDEA常用GIT操作入口 第一张图上的快捷入口可以基本满足开发的需求。 第二张图是更多在IDEA操作git的入口。 5.4、场景分析基于我们后面的实战模式，我们做一个综合练习 当前的开发环境如下，我们每个人都对这个项目已经开发一段时间，接下来我们要切换成团队开发模式。也就是我们由一个团队来完成这个项目实战的内容。团队有组长和若干组员组成（组长就是开发中的项目经理）。 所有操作都在idea中完成。 练习场景如下： 1 、由组长，基于本项目创建本地仓库；创建远程仓库，推送项目到远程仓库。 2 、每一位组员从远程仓库克隆项目到idea中,这样每位同学在自己电脑上就有了一个工作副本，可以正式的开始开发了。我们模拟两个组员(组员A、组员B)，克隆两个工作区。 3 、组员A修改工作区,提交到本地仓库，再推送到远程仓库。组员B可以直接从远程仓库获取最新的代码。 4 、组员A和组员B修改了同一个文件的同一行，提交到本地没有问题，但是推送到远程仓库时，后一个推送操作就会失败。 解决方法：需要先获取远程仓库的代码到本地仓库，编辑冲突，提交并推送代码。 附：几条铁令 切换分支前先提交本地的修改 代码及时提交，提交过了就不会丢 遇到任何问题都不要删除文件目录，第 1 时间找老师 附：疑难问题解决 windows下看不到隐藏的文件（.bashrc、.gitignore） windows下无法创建.ignore|.bashrc文件 这里以创建.ignore文件为例： 在git目录下打开gitbash 执行指令touch .gitignore 附：IDEA集成GitBash作为Terminal","raw":null,"content":null,"categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://lycode1202.github.io/tags/git/"}]},{"title":"hexo-matery博客目录结构","slug":"hexo博客目录解析","date":"2022-03-05T16:00:00.000Z","updated":"2022-03-18T08:56:13.272Z","comments":true,"path":"2022/03/06/hexo-bo-ke-mu-lu-jie-xi/","link":"","permalink":"https://lycode1202.github.io/2022/03/06/hexo-bo-ke-mu-lu-jie-xi/","excerpt":"","text":"目录部分 deploy_git，与git是git相关内容，如果无法git到仓库，需要检查git文件夹中配置 scaffolds，存放的是默认生成md文件的配置，其中post.md是默认生成文章的配置 scripts，扩展脚本目录，这里可以自定义一些javascript脚本存放的是页面加载脚本(非默认) source，hexo源码目录，是核心目录，下面详解 themes，是主题目录，下面详解 packages，是存放看板动画模型的(非默认) public，是通过hexo g编译出来的最终网页文件，也是部署到github上的文件，输出的静态网页内容目录 node_modules，是hexo的一些库文件 文件部分 _config.yml，是hexo的全局配置文件(核心配置文件)，一些插件安装后都需在此文件开启 CNAME，可配置个人域名 package.json，应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 main.py，个人快速执行脚本(非默认) source目录hexo的源码目录，写文章的主要目录 ├── _data # 存放友链的friends.json和相册的json ├── _posts # 所有文章就在这里 ├── 404 # 404相关 ├── categories # 归档页面 ├── contact # 关于页面 ├── friends # 友联页面 ├── galleries # 相册页面 ├── images # 图片页面，其他图，懒加载图存放位置 ├── media # 多媒体 ├── tags # 标签页 ├── 404.md # 404崩溃页面 └── CANME themes目录 hexo-theme-matery主题为例，**_config.yml是主题配置文件，非常重要** ├── languages # 多语言 | ├── default.yml # 默认语言 | └── zh-CN.yml # 中文语言 ├── layout # 布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial # 局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget # 小挂件的布局，页面下方小挂件的控制 ├── source # 源码 | ├── css # css源码 | | ├── _base # *.styl基础css | | ├── _partial # *.styl局部css | | ├── fonts # 字体 | | ├── images # 图片 | | └── style.styl # *.styl引入需要的css源码 | ├── fancybox # fancybox效果源码 | └── js # javascript源代码 ├── _config.yml # 主题配置文件 └── README.md # 用GitHub的都知道 layout目录目录部分 _partial主要修改文件 bg-cover-content.ejs # 主页背景图相关，banner图切换，打字机效果加字等 footer.ejs # 页脚配置 social-link.ejs # 修改社交链接，微信，qq，微博等 文件 404.ejs # 404页面 about.ejs # 关于我页面，个人简历 archive.ejs categories.ejs category.ejs contact.ejs douban.ejs # 豆瓣插件 friends.ejs galleries.ejs # 自定义相册 gallery.ejs # 自定义相册 index.ejs layout.ejs # 比较重要，我的天气，动态标签，鼠标点击特效等都在这开启 post.ejs tag.ejs tags.ejs 重点是这个layout.ejs，几乎所有自定义特效都在这个文件开启 source目录存放主题源码 ├── css #css源码 | ├── gallery.css # 相册css | ├── gitment.css | ├── matery.css # 主页的css相关调整，字体调整，主题色修改 | ├── my-gitalk.css | └── my.css # hexo-filter-github-emojis ├── js # javascript源代码，自定义js | ├── click.js # 鼠标点击特效 | ├── crypto-js.js # 加密相关 | ├── cursor.js # 雪花背景特效 | ├── fireworks.js # 鼠标点击烟花特效 | └── gallery-encrypt.js # 相册加密 ├── libs # 库文件，fancybox效果等插件需在这里打开 ├── medias # 主题内用到的背景图，图标，打赏图等都在这里 └── favicon.png # 网页标签图 js目录比较重要，所有自定特效，鼠标点击特效，背景特效在这里定义","raw":null,"content":null,"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lycode1202.github.io/tags/hexo/"}]},{"title":"hexo博客美化-基本配置","slug":"hexo博客美化","date":"2022-03-05T16:00:00.000Z","updated":"2022-03-18T09:06:26.626Z","comments":true,"path":"2022/03/06/hexo-bo-ke-mei-hua/","link":"","permalink":"https://lycode1202.github.io/2022/03/06/hexo-bo-ke-mei-hua/","excerpt":"","text":"主题下载与安装 说明：在之后提到的站点目录即根文件夹，主题目录就是主题文件夹，同理，站点配置文件就是根文件夹的配置文件，如我的：E:\\blog\\_config.yml，主题配置文件： E:\\blog\\themes\\matery\\_config.yml 在你的目录文件夹下使用 git clone 命令来下载：直接在站点根目录下执行下面的命令，即可进行主题的下载，主题有两个版本，稳定版本和最新版本(不定期更新优化)，自主选择版本，本文使用的是稳定版。 git clone https://gitee.com/yafine66/hexo-theme-matery themes/matery # 稳定版 git clone -b develop https://gitee.com/yafine66/hexo-theme-matery themes/matery #最新版(不定期进行优化更新) 切换主题： 将站点配置文件中的theme值修改为你下载主题的文件名，此处为matery，即theme: matery。 还需要修改的一些配置： 语言选择：如果为中文用户，则在language:后添加值zh-CN，如果不修改，默认为英语； 网址修改：url:的值为你的网址名，如http://xxxx.github.io； 站点配置文件有个per_page属性，建议修改为6的倍数，这样网站在适应设备时，有较好的显示效果。 1.增加功能1.1 增加页面 增加页面的步骤都基本相同，创建tags标签页、categories分类页，about关于我页、 contact留言板页、friends友情链接页、均可以使用这个步骤 如果在你的博客 source 目录下还没有，就输入以下命令（站点目录打开的命令行）来新建一个： hexo new page \"页面的英文\" # 如：hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2020-06-19 16:23:38 type: \"页面的英文\" # 如：type: \"tags\" layout: \"页面的英文\" # 如：layout: \"tags\" --- 关于 contact留言板页：留言板功能依赖于第三方评论系统，激活评论系统才有效果，下面会有介绍 关于friends友情链接页：如果你想增加内容，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，输入以下内容： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 1.2 菜单导航配置首先声明一下，一定要分清什么是站点配置文件，什么是主题文件，比如我在 F 盘新建我的博客文件夹，名称为 blog，那么站点配置文件的路径为 F:/blog/_config.yml，而你的主题配置文件路径为 F:/blog/themes/matery/_config.yml。 关于导航的配置都在主题配置文件中 1.2.1 配置基本菜单导航的名称、路径url和图标icon 导航名称可以设置成中文/英文 图标icon可以更换，具体属性值可以在fontawesome中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle 友人帐: #可以使用中文，也可以在对应的md中设置title:友人帐 url: /friends icon: fas fa-address-book 1.2.2 二级菜单配置方法 在需要添加二级菜单的一级菜单下添加children关键字(如:爱好菜单下添加children)，一级菜单不需要增加url属性 创建二级页面，步骤与创建页面步骤相同，编辑md时不需要layout属性 --- title: 追番 date: 2020-06-15 15:19:35 type: \"bangumis\" --- 给二级菜单增加名称name,路径url和图标icon 注意每个二级菜单模块前要加 - 二级菜单要缩进到一级菜单内 爱好: icon: fas fa-bicycle children: - name: 追番 url: /bangumis icon: fas fa-play-circle - name: 音乐 url: /musics icon: fas fa-music 1. 2.3修改主题的基本信息#这是根目录下的配置文件信息 title: 柠笙 #这是网站标题 subtitle: 柠笙 #这是网站副标题subtitle # 下面两个description,keywords，需要填上，如果想让搜索引擎收录，这个做SEO优化必不可忽视的两个属性 description: 专注于Web,分享生活,分享知识 #网站描述 keywords: [HTML, CSS, JavaScript, JQuery, React, Vue.js等] #网站的关键词 author: ly #作者，文章版权所显示的 language: zh-CN #网站语言，不填写，默认为英文 timezone: #时区，可以不填写 1.2.4 修改主题的 logo 图和 favicon 图标打开你的主题配置文件，找到如下的配置，将其更改为你的 logo 和 favicon 路径即可： # 配置网站favicon和网站LOGO favicon: /favicon.png logo: /favicon.png 1.2.5 去掉右上角的 github 图标打开你的主题配置文件，找到下面的配置: # Whether to display fork me on github icon and link, default true, You can change it to your repo address # 配置是否在 header 中显示 fork me on github 的图标，默认为true，你可以修改为你的仓库地址. githubLink: enable: true url: https://github.com/blinkfox/hexo-theme-matery title: Fork Me 将 enable 的属性值由 true 改为 false 即可。 1.2.6 去掉主页的 Github 按钮打开主题配置文件，找到下面的配置： # 首页 banner 中的第二个按钮的配置，包括按钮的显示名称、font awesome图标和按钮的超链接. indexbtn: enable: true name: Github icon: fab fa-github-alt url: https://github.com/blinkfox/hexo-theme-matery 将 enable 属性值由 true 改为 false 即可。 1.2.7 修改社交链接主页 banner 图中显示的社交链接与底部的社交链接是同步修改的，打开主题配置文件，将社交链接信息修改为你的信息。修改如下: # 首页 banner 中的第二行个人信息配置，留空即不启用 socialLink: github: https://github.com/blinkfox email: 1181062873@qq.com facebook: # https://www.facebook.com/xxx twitter: # https://twitter.com/xxx qq: 1181062873 weibo: # https://weibo.com/xxx zhihu: # https://www.zhihu.com/xxx rss: true # true、false 如果想添加简书，CSDN，掘金，博客园等等，需要在主题配置文件添加相关配置，如下是我个人的配置： socialLink: qq: 1035800145 weixin: https://cdn.jsdelivr.net/gh/Yafine/Yafine-imgs/images/wechat.png github: https://github.com/Yafine email: mailto:1035800145@qq.com facebook: # https://www.facebook.com/xxx twitter: # https://twitter.com/xxx weibo: # https://weibo.com/xxx zhihu: https://www.zhihu.com/people/xuan-tian-40-64/activities juejin: https://juejin.im/user/5a902053f265da4e7527ae71/activities csdn: https://blog.csdn.net/victoryxa jianshu: https://www.jianshu.com/u/3b3856869772 cnblogs: https://www.cnblogs.com/yafine/ rss: true # true、false 其中的 weixin 我是用的图片链接，会跳转到一个新的标签页，之后还需要修改 ejs 文件，文件在主题目录下的 layout 文件夹下的_partial 文件夹，修改 social-link.ejs，添加相关的配置，我个人添加的配置如下： javascript &lt;% if (theme.socialLink.jianshu) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.jianshu %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"关注我的简书: &lt;%= theme.socialLink.jianshu %&gt;\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-jianshu\"&gt;简&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; &lt;% if (theme.socialLink.csdn) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.csdn %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"关注我的CSDN: &lt;%= theme.socialLink.csdn %&gt;\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-csdn\"&gt;C&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; &lt;% if (theme.socialLink.juejin) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.juejin %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"关注我的掘金: &lt;%= theme.socialLink.juejin %&gt;\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-juejin\"&gt;掘&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; &lt;% if (theme.socialLink.cnblogs) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.cnblogs %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"关注我的博客园: &lt;%= theme.socialLink.cnblogs %&gt;\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-juejin\"&gt;博&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; &lt;% if (theme.socialLink.weixin) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.weixin %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"微信联系我: &lt;%= theme.socialLink.weixin %&gt;\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-weixin\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 1.2.8 去掉 banner 图的动态滤镜颜色并修改导航栏颜色 去掉动态滤镜颜色 打开 themes/matery/source/css/matery.css 文件，查找下面的代码块，然后将其注释即可。如下： css .bg-cover:after { -webkit-animation: rainbow 60s infinite; animation: rainbow 60s infinite; } 或者是找到如下代码，将其注释掉即可： css /*如果想去掉banner图的颜色渐变效果，请将以下的css属性注释掉或者删除掉即可*/ @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } 上面的两段代码是有关联的，将.bg-cover:after 这段代码注释掉，上面的代码就不会起作用了。 修改导航栏颜色及透明效果 打开 themes/matery/source/css/matery.css 文件，大约在 250 行，有一个.bg-color 属性，修改其属性值即可，代码如下： css .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值 opacity: 0.8; //透明效果 值范围 0~1，看情况自己修改 } 1.2.9 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： javascript $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 如果想改为每小时或者每分钟切换 banner 图的话，需要将 getDay() 改为 getHours() 或者 getMinutes() 即可。 注意：这个不会自动切换 banner 图，需要刷新页面才可以，更换为每分钟或每小时可能会出现问题，如图片显示不出来，具体的解决办法，自己研究吧😂，可能是图片数量不足，或者是图片命名规范的问题。 1.2.10 添加首页动态打字效果副标题在主题配置文件中，找到下面的配置： yml # 网站副标题，打字效果 # 如果有符号 ‘ ，请在 ’ 前面加上 \\ subtitle: enable: true loop: true # 是否循环 showCursor: true # 是否显示光标 startDelay: 300 # 开始延迟 typeSpeed: 100 # 打字速度 backSpeed: 50 # 删除速度 sub1: 志之所向，金石为开，谁能御之？ sub2: 花开不是为了花落，而是为了开的更加灿烂。 sub3: 没有伞的孩子必须努力奔跑！ sub4: 欲望以提升热忱，毅力以磨平高山。 sub5: 如果放弃太早，你永远都不知道自己会错过什么。 sub6: 没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。 注意： 网站打字效果副标题默认有两个，即 sub1 和 sub2，如果想写多个，则需要修改两处地方，首先修改配置文件，如上面所示，在 sub1 和 sub2 后面继续添加即可，然后在去主题目录下的 layout 文件夹下的_partial 文件夹，修改 bg-cover-content.ejs 文件，大约在 12 行左右，如下面所示： javascript &lt;div class=\"description center-align\"&gt; &lt;% if (theme.subtitle.enable) { %&gt; &lt;span id=\"subtitle\"&gt;&lt;/span&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt; var typed = new Typed(\"#subtitle\", { strings: ['&lt;%= theme.subtitle.sub1 %&gt;', '&lt;%= theme.subtitle.sub2 %&gt;', '&lt;%= theme.subtitle.sub3 %&gt;', '&lt;%= theme.subtitle.sub4 %&gt;', '&lt;%= theme.subtitle.sub5 %&gt;', '&lt;%= theme.subtitle.sub6 %&gt;'], startDelay: &lt;%= theme.subtitle.startDelay %&gt;, typeSpeed: &lt;%= theme.subtitle.typeSpeed %&gt;, loop: &lt;%= theme.subtitle.loop %&gt;, backSpeed: &lt;%= theme.subtitle.backSpeed %&gt;, showCursor: &lt;%= theme.subtitle.showCursor %&gt; }); &lt;/script&gt; &lt;% } else { %&gt; &lt;%= config.description %&gt; &lt;% } %&gt; &lt;/div&gt; 1.2.11 动态标题实现方法，引入 js 文件，在主题文件下的 /source/js/ 下新建 FunnyTitle.js，然后在添加到 themes/matery/layout/layout.ejs 或者添加到 themes/matery/layout/_partial/head.ejs，其代码如下： javascript &lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/favicon.png\"); document.title = 'ヽ(●-`Д´-)ノ你要玩捉迷藏嘛'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/favicon.png\"); document.title = 'ヾ(Ő∀Ő3)ノ好哦！' + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); 或者直接在 themes/matery/layout/layout.ejs 文件中添加如下代码： javascript &lt;script type=\"text/javascript\"&gt; var OriginTitile=document.title,st; document.addEventListener(\"visibilitychange\",function(){ document.hidden?(document.title=\"ヽ(●-`Д´-)ノ你要玩捉迷藏嘛\",clearTimeout(st)):(document.title=\"(Ő∀Ő3)ノ好哦！\",st=setTimeout(function(){document.title=OriginTitile},3e3)) }) &lt;/script&gt; 1.2.12 修改导航栏颜色以及透明效果打开 themes/matery/source/css/matery.css 文件，大约在 250 行，有一个.bg-color 属性，修改其属性值即可，代码如下： css .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值 opacity: 0.8; //透明效果 值范围 0~1，看情况自己修改 } 1.2.13 修改打赏二维码在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 1.3 增加番剧、音乐页面 此处可以设置一个二级导航爱好，将这些归纳到一个导航中效果更佳 1.3.1 Bilibili 需要插件来获取你的番剧 安装插件 npm install hexo-bilibili-bangumi --save 安装番剧更新插件 npm install hexo-bilibili-bangumi --update --save 配置 将下面的配置写入站点配置文件_config.yml里（非主题） bangumi: enable: true #是否开启 vmid: 1234567 #输入你番剧的uid，登录网址https://space.bilibili.com/1234567，后面数字就是你的uid title: '追番列表' # 标题 quote: '生命不息，追番不止！' # 简介 show: 1 # 初始显示页面：0: 想看 , 1: 在看 , 2: 看过，默认为 1 loading: '/img/bangumi-loading.gif' # 图片加载完成前的 loading 图片 创建番剧页面 输入命令 hexo new page bangumis 找到source/bangumis/index.md这个文件，修改这个文件，添加 type: \"bangumis\" ```yamltitle: bangumisdate: 2020-06-18 00:00:00 type: “bangumis” 配置番剧页面为二级导航栏 参考上边的二级导航栏配置方式 使用 输入命令，更新番剧数据 hexo clean &amp;&amp; hexo g &amp;&amp; hexo bangumi -u &amp;&amp; hexo s 更新时遇到的坑： 错误：配置都完全正确，却出现Get bangumi data error 原因：你的B站设置了番剧仅自己可见 解决方法：进入B站个人空间，点击设置，将追番追剧设置为公开 如果想要删除数据，可以输入该命令 hexo bangumi -d 注意：该插件不需要我们每次部署都要输入更新数据的命令，只有你自己番剧更新时才需要执行更新指令，之前的番剧数据会一直保留，直到被你删除 1.3.2 网易云音乐 这个就非常简单了，不需要安装任何插件，只需要创建新页面，配置二级导航即可 创建音乐页面 输入命令 hexo new page musics 找到source/musics/index.md这个文件，修改这个文件，添加 type: \"music\" --- title: 音乐！音乐！ date: 2020-06-16 14:45:30 type: 'music' --- 在index.md文件中增加以下内容 &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=520 src=\"//music.163.com/outchain/player?type=0&amp;id=2817562565&amp;auto=1&amp;height=430\">&lt;/iframe> 第二行的id的那串数字，需要改成你想要的歌单id 查看自己id的方式： 点击网易云音乐软件，找到想设置的歌单→分享→复制链接 https://music.163.com/playlist?id=531558923&amp;userid=375531677 id则是你想要的id，不是后面的userid 配置音乐页面为二级导航栏 参考上边的二级导航栏配置方式 1.4 增加自定义相册 修改的原因： matery主题原有的相册效果不佳，原因在于全部采用平铺式，没有分类的功能，自定义相册可以建立文件夹，方便分类 注意：本教程采用图床+CDN，图床采用的是github+Picgo 关于图床和cdn是什么： 通俗来说就是将本地图片上传到网上，通过cdn加速来加快读取图片的一种方式 具体看励心大佬关于github图床搭建的教程 新建相册页面 执行以下命令： hexo new page galleries 到站点根目录的source目录下找名称为 **galleries** 的目录，打开目录下的 **index.md** 文档，添加以下配置： title: 相册 date: 2020-06-13 10:59:30 type: \"galleries\" layout: \"galleries\" 配置导航菜单 在主题配置文件中menu加上 相册: url: /galleries icon: fas fa-image 创建ejs文件和css文件 在路径 matery/source/css目录下，新建gallery.css，增加以下代码 .gallery-wrapper{ padding-top: 30px; } .gallery-wrapper .gallery-box{ padding: 5px !important; } .gallery-wrapper .gallery-item { display: block; overflow: hidden; background-color: #fff; padding: 5px; padding-bottom: 0; position: relative; -moz-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); -webkit-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); } .gallery-cover-box{ width: 100%; padding-top: 60%; text-align: center; overflow: hidden; position: relative; background: center center no-repeat; -webkit-background-size: cover; background-size: cover; } .gallery-cover-box .gallery-cover-img { display: inline-block; width: 100%; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); } .gallery-item .gallery-name{ font-size: 14px; line-height: 24px; text-align: center; color: #666; margin: 0; } .waterfall { column-count: 3; column-gap: 1em; } .photo-wrapper{ padding-top: 20px; } .photo-item { display: block; padding: 10px; padding-bottom: 0; margin-bottom: 14px; font-size: 0; -moz-page-break-inside: avoid; -webkit-column-break-inside: avoid; break-inside: avoid; background: white; -moz-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); -webkit-box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.22); } .photo-item img { width: 100%; } .photo-item .photo-name{ font-size: 14px; line-height: 30px; text-align: center; margin-top: 10px; margin-bottom: 10px; border-top: 1px solid #dddddd; } /*适配移动端布局*/ @media only screen and (max-width: 601px) { .waterfall { column-count: 2; column-gap: 1em; } } 在matery/layout 目录下创建 galleries.ejs ，增加以下代码，并修改代码 &lt;link rel=\"stylesheet\" href=\"/css/gallery.css\"> &lt;%- partial('_partial/bg-cover') %> &lt;main class=\"content\"> &lt;div class=\"container\"> &lt;% if (site.data &amp;&amp; site.data.galleries) { %> &lt;% var galleries = site.data.galleries; %> &lt;div class=\"gallery-wrapper row\"> &lt;% for (var i = 0, len = galleries.length; i &lt; len; i++) { %> &lt;% var gallery = galleries[i]; %> &lt;div class=\"col s6 m4 l4 xl3 gallery-box\"> &lt;a href=\"./&lt;%- gallery.name %>\" class=\"gallery-item\" data-aos=\"zoom-in-up\"> &lt;div class=\"gallery-cover-box\" style=\"background-image: url(你的链接&lt;%- gallery.cover%>);\"> &lt;/div> &lt;p class=\"gallery-name\"> &lt;%- gallery.name %> &lt;/p> &lt;/a> &lt;/div> &lt;% } %> &lt;/div> &lt;% } %> &lt;/div> &lt;/main> 修改代码： 在你的链接这填写你相册图床的根网址，解释一下什么叫根网址， 一张图片的目录是https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/123/aaa.jpg 那么它的根目录就是https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/，123/只是图床中的一个文件夹 比如我的修改为：url(https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/&lt;%- gallery.cover%&gt;);”&gt; 仍然在此目录新建gallery.ejs文件，添加以下代码，并修改代码： &lt;link rel=\"stylesheet\" href=\"/css/gallery.css\"> &lt;link type=\"text/css\" href=\"/libs/fancybox/jquery.fancybox.css\" rel=\"stylesheet\"> &lt;link type=\"text/css\" href=\"/libs/justifiedGallery/justifiedGallery.min.css\" rel=\"stylesheet\"> &lt;%- partial('_partial/post-cover') %> &lt;% let galleries = []; if (site.data &amp;&amp; site.data.galleries) { galleries = site.data.galleries; } var pageTitle = page.title; function getCurrentGallery(galleries, pageTitle) { for (let i = 0; i &lt; galleries.length; i++) { if (galleries[i]['name'] == pageTitle) { return galleries[i]; } } } var currentGallery = getCurrentGallery(galleries, pageTitle) var photos = currentGallery.photos; let imageStr = '' for (var i = 0, len = photos.length; i &lt; len; i++) { var photo = photos[i]; imageStr += \"&lt;a href=\\\"你的链接\" + photo + \"\\\"\" + \" class=\\\"photo-item\\\" rel=\\\"example_group\\\"\" + \" data-fancybox=\\\"images\\\">\" + \" &lt;img src=\\\"你的链接\" + photo + \"\\\"\" + \" alt=\" + photo + \">\\n\" + \" &lt;/a>\" } %> &lt;div class=\"container\"> &lt;div class=\"photo-wrapper\"> &lt;% if (page.password ) { %> &lt;script src=\"/js/crypto-js.js\">&lt;/script> &lt;script src=\"/js/gallery-encrypt.js\">&lt;/script> &lt;div id=\"hbe-security\"> &lt;div class=\"hbe-input-container\"> &lt;input type=\"password\" class=\"hbe-form-control\" id=\"pass\" placeholder=\"请输入密码查看内容\"/> &lt;a href=\"javascript:;\" class=\"btn-decrypt\" id=\"btn_decrypt\">解密&lt;/a> &lt;/div> &lt;/div> &lt;div id=\"mygallery\"> &lt;div class=\"waterfall\" id=\"encrypt-blog\" style=\"display:none\"> &lt;%- aes(imageStr, page.password) %> &lt;/div> &lt;/div> &lt;% } else { %> &lt;div class=\"waterfall\" id=\"encrypt-blog\"> &lt;%- imageStr %> &lt;/div> &lt;% } %> &lt;/div> &lt;/div> &lt;script src=\"/libs/fancybox/fancybox.js\">&lt;/script> &lt;script src=\"/libs/justifiedGallery/justifiedGallery.min.js\">&lt;/script> &lt;script> $(\"a[rel=example_group]\").fancybox(); $(\"#encrypt-blog\").justifiedGallery({margins: 5, rowHeight: 150}); &lt;/script> 修改代码： 在你的链接这填写你相册图床的根网址 注意：最后一定要带上 / 添加相册json配置文件 在根目录source\\_data新建 galleries.json 的文件，增加json 代码如下： [ { \"name\": \"相册名字\", \"cover\": \"images/p0.png\", \"description\": \"相册的描述\", \"photos\": [ \"images/node-1.png\", \"images/node-2.png\", \"images/node-3.png\", \"images/node-4.png\", \"images/node-5.png\", \"images/node-6.png\", \"images/node-7.png\", ] } ] 属性介绍： cover：相册的封面，值为图片的地址 photos：图片的地址，输入了地址界面才会显示该图片，前提是图床中有该图片 新建相册 在galleries目录下建立对应的相册名称目录和文件，比如我这个相册需要新建名称为 2020 文件夹，然后在文件夹中新建index.md文件，文件内容为： --- title: 2020 date: 2020-02-19 10:51:50 type: \"gallery\" layout: \"gallery\" --- 查看效果 重新部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 1.5 增加emoji支持😄 使你markdown博客里的emoji表情跳动起来 安装插件 npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 重新部署即可查看 小坑：在配置支持前发布的文章中的表情并没有获得支持，并且连表情都不会显示，所以最好在配置之后再输入表情进行测试 1.6代码高亮由于 Hexo 自带的代码高亮主题显示不好看，用一个插件来替换它 安装插件 npm i -S hexo-prism-plugin 修改 Hexo 站点配置文件 _config.yml 中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 1.7 搜索功能实现文章内容搜索 安装插件 npm install hexo-generator-search --save 在 Hexo 站点配置文件 _config.yml 中，新增以下的配置项： search: path: search.xml field: post 1.8 中文链接转拼音如果你的文章名称是中文的，那么 Hexo 默认生成的文章链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装插件 npm i hexo-permalink-pinyin --save 在 Hexo 站点配置文件 _config.yml 中，新增以下的配置项： permalink_pinyin: enable: true separator: '-' # default: '-' 1.9 文章字数统计插件用于在文章中显示文章字数、阅读时长信息 安装插件 npm i --save hexo-wordcount 在主题配置文件_config.yml 文件中，激活以下配置项即可： wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 1.10 配置音乐播放器想支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： # 是否在首页显示音乐. music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 autoHide: false # hide automaticaly server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 411680085 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 hideLrc: true # 隐藏歌词 属性介绍： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐） type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 小坑：matery主题不支持ajax异步机制，在切换页面时音乐也会切换，不会继续一首歌播放所以这个功能比较鸡肋，在于自己取舍 1.11 关于我页面添加个人简历打开theme/matery/layout/about.ejs文件，大约在13行。有一个card标签，找出其对应结尾的标签，大约在61行左右，然后在下面新增如下代码 &nbsp;&nbsp; 注意粘贴的位置和空格要正确，这里的位置随你自己设置，你也可以把简历作为第一个card，然后/source/about/index.md下面写上你的简历了（就像写博客一样）。 1.12 配置404错误页面站点根目录下的source文件夹下新建404.md文件，里面内容如下： --- title: 404 date: 2020-6-18 16:41:10 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面了\" --- 在主题文件夹的layout目录下新建404.ejs文件，添加内容如下： /* don't remove. */ .about-cover { height: 90.2vh; } 404 // 每天切换 banner 图. Switch banner image every day. $('.bg-cover').css('background-image', 'url(https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.1/source/medias/banner/' + new Date().getDay() + '.jpg)'); 然后部署，再看看效果即可http://localhost:4000/404/ 1.13 添加Valine评论系统编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey. valine: enable: true appId: Ucrxxxxxxxxxxxxxxxx-xxxxsz # 自行注册valine获取 appKey: zPsLxxxxxxxxxxxxxxerLmd # 自行注册valine获取 notify: true verify: true visitor: true avatar: 'monsterid' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '留下你的足迹..' # Comment Box placeholder background: /medias/comment_bg.png count: true enableQQ: 16463223 # 改为自己的QQ号 recordIP: true requiredFields: - nick - mail guest_info: - nick - mail - link master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 metaPlaceholder: # 输入框的背景文字 nick: 昵称/QQ号(必填) mail: 邮箱(必填) link: 网址(https://) lang: zh-CN tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode] - 博主 - 小伙伴 - 访客 friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode] - cb3e577ff029d6073400d5557effd41f - 1.14 修改公告(dream一栏)里的每日一句找到/themes/matery/layout/index.ejs，第17行改为： &lt;% if (theme.dream.enable) { %> &lt;!-- &lt;%- partial('_widget/dream') %> --> &lt;i class=\"fa fa-volume-up fa-lg fa-fw text-color\">&lt;/i> &lt;%- '&lt;span id=\"hitokoto\">一言API请求超时。请稍后重试。&lt;/span> （来源：一言API）' %> &lt;% } %> 同时在/themes/matery/layout/_partial/head.ejs增加代码： &lt;script src=\"https://v1.hitokoto.cn/?c=d&amp;encode=js&amp;select=%23hitokoto\" defer>&lt;/script> 1.15 添加动态诗词采用的是今日诗词，每次返回一句诗词，根据时间、地点、天气、事件智能推荐。官网有 API 文档，可以去看一下，有多种安装方式，最简单的方式就是从官网获取代码，在 /themes/matery/layout/_partial/head.ejs 添加下面的一行代码： javascript &lt;script src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 然后再将 /themes/matery/layout/_partial/bg-cover-content.ejs 中的 &lt;%= config.description %&gt; 修改为 &lt;%- '&lt;span id=\"jinrishici-sentence\"&gt;正在加载今日诗词....&lt;/span&gt;' %&gt;，这个使用前提是将主题配置文件的 subtitle 的值改为 false。 1.16 鼠标点击文字特效实现方法，引入 js 文件，在主题文件下的 /source/js/ 下新建 click_show_text.js，其代码如下： javascript 复制成功var a_idx = 0; jQuery(document).ready(function ($) { $(\"body\").click(function (e) { var a = new Array(\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\"); var $i = $(\"&lt;span/&gt;\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 5, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"#FF0000\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 3000, function () { $i.remove(); }); }); setTimeout('delay()', 2000); }); function delay() { $(\".buryit\").removeAttr(\"onclick\"); } 或者使用我的 cdn 链接，理论上一直有效 https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.4/source/js/click_show_text.js，然后在添加到 themes/matery/layout/layout.ejs。 1.17 鼠标点击礼花特效文件地址：传送门 在 matery/source/js/ 目录下新建 lihua.js，然后打开上面的传送门网址，将代码复制粘贴进 js 文件里，然后在 layout.ejs 文件里引用，最后本地运行查看效果即可。 1.18 自定义鼠标样式建议大家下载鼠标指针样式的格式为 ico 格式，大小为 1616，或者 2424 的。 首先将鼠标样式下载到本地，推荐大家一个网站，可以免费下载，不过需要登录一下：网址为：https://www.easyicon.net/ 以我的为例，我将鼠标指针样式放在了主题文件夹下的 medias 目录下，然后打开主题文件夹下的 my.css 文件，添加内容如下： css *{ cursor: url(\"/medias/cursor1.ico\"),auto!important; } :active{ cursor: url(\"/medias/cursor2.ico\"),auto!important; } 然后在本地运行查看效果即可 1.19 添加鼠标彩虹星星掉落跟随效果在 themes/matery/source/js 目录下新建 cursor.js 文件，打开这个网址传送门，将内容复制粘贴到 cursor.js 即可。 然后再 themes/matery/layout/layout.ejs 文件内添加下面的内容： javascript &lt;script src=\"/js/cursor.js\"&gt;&lt;/script&gt; 1.20 在 Hexo 博客中创建自定义页面使用hexo创建的静态博客，所有博文内容都是有markdown生成，且页面样式也是由下载的主题自动化生成的，那么想要在独立页面中大展身手的前端小伙伴，如何将写好的静态页面引入到hexo博客中呢？html，css，js等文件在hexo项目里如何避免被自动渲染呢？ 打开hexo项目根目录下的配置文件_config.yml，找到skip_render:，在这里就可以配置需要跳过渲染的文件。 例如，我们把所有静态页面放到source文件夹下的demo文件夹中，只要配置 skip_render: demo/** 就可以使demo下的所有文件（包括子文件）避免被编译。 skip_render: demo/* # 屏蔽demo文件夹下的文件，不包括子文件夹内的内容 skip_render: demo/** # 屏蔽demo文件夹下的所有文件，包括子文件夹内的内容 skip_render: demo/index.html # 屏蔽demo文件夹下的index.html，特指一个文件 skip_render: demo/*.html # 屏蔽demo文件夹下的所有html文件 写多个筛选条件时 skip_render: - space/** - demo/* 随后即可 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 2. 博客优化2.1 gulp代码压缩 hexo生成的html、css、js等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的“压缩”，减小一点资源文件的大小也是对访问速度有那么一点提升的。 在站点目录执行以下命令，安装插件 # 全局安装gulp模块 npm install gulp -g # 安装各种小功能模块 执行这步的时候，可能会提示权限的问题，最好以管理员模式执行 npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save # 额外的功能模块 npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save 在Hexo根目录新建文件 gulpfile.js，并复制以下内容到文件中，有中文注释，可以根据自己需求修改。（注意：文件名不能错，一定为gulpfile.js，否则会出错！） var gulp = require(\"gulp\"); var debug = require(\"gulp-debug\"); var cleancss = require(\"gulp-clean-css\"); //css压缩组件 var uglify = require(\"gulp-uglify\"); //js压缩组件 var htmlmin = require(\"gulp-htmlmin\"); //html压缩组件 var htmlclean = require(\"gulp-htmlclean\"); //html清理组件 var imagemin = require(\"gulp-imagemin\"); //图片压缩组件 var changed = require(\"gulp-changed\"); //文件更改校验组件 var gulpif = require(\"gulp-if\"); //任务 帮助调用组件 var plumber = require(\"gulp-plumber\"); //容错组件（发生错误不跳出任务，并报出错误内容） var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件) var isDebug = true; //是否调试显示 编译通过的文件 var gulpBabel = require(\"gulp-babel\"); var es2015Preset = require(\"babel-preset-es2015\"); var del = require(\"del\"); var Hexo = require(\"hexo\"); var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象 // 清除public文件夹 gulp.task(\"clean\", function () { return del([\"public/**/*\"]); }); // 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return // 创建静态页面 （等同 hexo generate） gulp.task(\"generate\", function () { return hexo.init().then(function () { return hexo .call(\"generate\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); }); }); // 启动Hexo服务器 gulp.task(\"server\", function () { return hexo .init() .then(function () { return hexo.call(\"server\", {}); }) .catch(function (err) { console.log(err); }); }); // 部署到服务器 gulp.task(\"deploy\", function () { return hexo.init().then(function () { return hexo .call(\"deploy\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); }); }); // 压缩public目录下的js文件 gulp.task(\"compressJs\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/libs/**\"]) //排除的js .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress JS:\" }))) .pipe(plumber()) .pipe( gulpBabel({ presets: [es2015Preset] // es5检查机制 }) ) .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩 .pipe(gulp.dest(\"./public\")); //输出到目标目录 }); // 压缩public目录下的css文件 gulp.task(\"compressCss\", function () { var option = { rebase: false, //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: \"ie7\" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 }; return gulp .src([\"./public/**/*.css\", \"!./public/**/*.min.css\"]) //排除的css .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress CSS:\" }))) .pipe(plumber()) .pipe(cleancss(option)) .pipe(gulp.dest(\"./public\")); }); // 压缩public目录下的html文件 gulp.task(\"compressHtml\", function () { var cleanOptions = { protect: /&lt;\\!--%fooTemplate\\b.*?%-->/g, //忽略处理 unprotect: /&lt;script [^>]*\\btype=\"text\\/x-handlebars-template\"[\\s\\S]+?&lt;\\/script>/gi //特殊处理 }; var minOption = { collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/> ==> &lt;input /> removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /> ==> &lt;input /> removeScriptTypeAttributes: true, //删除&lt;script>的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style>和&lt;link>的type=\"text/css\" removeComments: true, //清除HTML注释 minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true //替换页面URL }; return gulp .src(\"./public/**/*.html\") .pipe(gulpif(isDebug, debug({ title: \"Compress HTML:\" }))) .pipe(plumber()) .pipe(htmlclean(cleanOptions)) .pipe(htmlmin(minOption)) .pipe(gulp.dest(\"./public\")); }); // 压缩 public/medias 目录内图片 gulp.task(\"compressImage\", function () { var option = { optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化 }; return gulp .src(\"./public/medias/**/*.*\") .pipe(gulpif(!isScriptAll, changed(\"./public/medias\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress Images:\" }))) .pipe(plumber()) .pipe(imagemin(option)) .pipe(gulp.dest(\"./public\")); }); // 执行顺序： 清除public目录 -> 产生原始博客内容 -> 执行压缩混淆 -> 部署到服务器 gulp.task( \"build\", gulp.series( \"clean\", \"generate\", \"compressHtml\", \"compressCss\", \"compressJs\", gulp.parallel(\"deploy\") ) ); // 默认任务 gulp.task( \"default\", gulp.series( \"clean\", \"generate\", gulp.parallel(\"compressHtml\", \"compressCss\", \"compressJs\") ) ); //Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数 注意：这里我去掉了图片的压缩，如果想要加上可以在第154行加上 “compressImage”, 和第165行的加上”compressImage” 即可 使用（两种方式）： 直接在Hexo根目录执行 gulp，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码压缩，再hexo s进行部署即可 在Hexo根目录执行 gulp build ，这个命令与第1种相比是：在最后又加了个 hexo d ，等于说生成、压缩文件后又帮你自动部署了 2.2 CDN加速 关于CDN是什么？参考励心大佬 由于我们将博客部署到了国外的Github上，国内访问速度很慢，我们可以使用这个技术来实现全站加速 在理解了CDN的含义和该如何使用CDN的前提下，matery主题有一个很人性化的操作，不需要我们将每个资源都逐个设置，在主题配置文件_config.yml中搜索jsDelivr，填写url为自己的博客仓库即可，如我的： jsDelivr: url: https://cdn.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io 此时重新hexo cl &amp;&amp; hexo g &amp;&amp; hexo d部署你的项目体验效果，网站的加载速度会快很多（先看小苏经历的坑）。 关于CDN加速的坑： 配置了此项，就代表着hexo s本地调试的时候，网站依然会去GitHub请求资源（原来的资源），所以本地调试的时候记得将 此项配置 注释或者删除掉； 在hexo s本地调试好之后，需要hexo d部署到网上，要先配置到url，之后再hexo cl &amp;&amp; hexo g &amp;&amp; hexo d进行部署，否则不生效； 使用了matery提供的全局CDN加速，有可能你的樱花散落，鼠标图标等一些特效消失，具体原因还不清楚，不过加速效果才是小苏想要的，就舍弃掉了这些特效。 2.3 打造图床 图床的选择有免费和收费，在这里推荐一种免费搭建图床的方式： PicGo+Github：https://yafine-blog.cn/posts/eb3a.html 有了图床，我们可以实现自定义相册、markdown基于图床上传图片的功能，很强大 2.4 部署到Coding 在上面的教程我们可以将博客部署到国外Github的仓库上，我们也可以将博客部署到国内Coding、Gitee仓库上，可以提高一些网站访问的速度，小苏只使用了Coding，这里也介绍一下。 https://fenghen0918.github.io/2020/06/20/hexo-bo-ke-bu-shu-dao-coding/ 2.5 新建文章自动打开本地Markdown编辑器 写新文章时，需要控制台执行hexo new “文章名字”生成一篇新文章，但需要手动打开，挺麻烦，我们可以设置在生成之后自动打开 在站点根目录下新建scripts目录，然后在新建auto_open.js，在文件填入一下内容： var spawn = require('child_process').exec; // Hexo 2.x 用户复制这段 //hexo.on('new', function(path){ //spawn('start \"markdown编辑器绝对路径.exe\" ' + path); //}); // Hexo 3 用户复制这段 hexo.on('new', function(data){ spawn('start \"D:\\Program Files\\Typora\\Typora.exe\" ' + data.path); }); 其中”D:\\Program Files\\Typora\\Typora.exe”是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行hexo cl &amp;&amp; hexo g -d，部署到GitHub即可，以后在发布文章就会自动打开编辑器。","raw":null,"content":null,"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lycode1202.github.io/tags/hexo/"}]}]}